#!/bin/bash

# License: GNU Lesser General Public License v3.0
# See: http://www.gnu.org/licenses/lgpl-3.0.html
# Written by Carsten Jacob
# Please feel free to contact me coding@langstreckentouren.de
# https://github.com/CarstenHa

# Wenn neue vcf-Elemente aufgenommen werden sollen, hier die wichtigen Abschnitte:
# 1. Funktion vcfvorlage
# 2. Funktion datenabfrage
# 3. Option -m Variable allmodtype (und Variable arraylist)
# 4. Option -n löschen aus vcf-Gerüst bei leerer Variable
# 5. Eintrag in printf-Bereich (Ausgabe auf Bildschirm)
# 6. if-Verzweigung ("$modifytype") hinzufügen inkl. Quoting von /

# Wenn ein neuer Messenger aufgenommen werden soll, sind die entsprechenden Bereiche im Quellcode markiert mit:
# MessDef

# Mit readlink kann man den tatsächlichen Speicherort des Skriptes ermitteln.
pathofaddress="$(dirname $(readlink -f ${0}))"

if [ ! -e "${pathofaddress}/config/addressli.conf" ]; then
 echo -e "Datei ${pathofaddress}/config/addressli.conf existiert nicht. Bitte erst anlegen.\nEine Beispieldatei finden Sie unter:\nhttps://raw.githubusercontent.com/CarstenHa/addressli/master/config/example.conf\nSkript wird abgebrochen!"
 exit 1
else
 conffile="${pathofaddress}/config/addressli.conf"
 source "$conffile" 2>/dev/null
fi

if [ -z "$(type -p ccrypt)" ]; then
 echo -e "Das Programm ccrypt zur Entschlüsselung der Adressdaten muss installiert sein.\nBitte sudo apt-get install ccrypt ausführen und dieses Skript neu starten."
 exit 1
fi

if [ ! -e "${pathofaddress}/address.lst.cpt" ]; then
 if [ -e "${pathofaddress}/address.lst" ]; then
  echo "Datei liegt unverschlüsselt im Verzeichnis. Diese wird jetzt verschlüsselt."
  ccencrypt "${pathofaddress}/address.lst"
  while [ ! "$?" == "0" ]; do
   echo "Bitte Passwort erneut eingeben:"
   ccencrypt "${pathofaddress}/address.lst"
  done
 else
  echo "${pathofaddress}/address.lst existiert nicht. Skript wird abgebrochen."
  exit 1
 fi
fi
if [ -z "$(type -p qrencode)" ]; then
 echo "Das Programm qrencode muss installiert sein. Skript wird abgebrochen."
 exit 1
fi

# ********** Funktionen - Anfang  **********
# MessDef1 (-n)
usage() {
cat <<EOU

SYNOPSIS Beispiele:

	$0 NAME [VORNAME]
	$0 \*
	$0 [OPTION]
	$0 [OPTION] ARG
	$0 -e ARG YYYY
	$0 -DC LÄNDERRCODE -F LÄNDERRCODE [YYYY]

$(basename $0) ist eine kleine Adressverwaltung für die Konsole.
Es stehen folgende Optionen zur Verfügung:
 
Options:

   -c

	Kalender des laufenden Monats wird angezeigt.

   -C ARG [YYYY]

	Jahreskalender mit Feiertagen wird angezeigt. Benötigt eine der folgenden Angaben:
	1. ? Damit werden die definierten Ländercodes aus config/addressli.conf aufgelistet
	     und abgefragt.
	Es kann auch ein alternativer Ländercode angegeben werden, der nicht in der config-Datei
	definiert ist. Dieser wird dann anstelle eines Ländercodes aus der config-Datei übernommen.
	2. Angabe eines alternativen Ländercodes aus gcal-Liste
	3. l Mit 'l' werden die Ländercodes aufgelistet.

	Beispiel:
	AD (für Andorra)
	Bei optionaler Angabe einer Jahreszahl werden die Feiertage des angegebenen Jahres angezeigt.
	Die Jahreszahl muss als letztes Argument angegeben werden.
	Die Option -C ist mit den Optionen -D und -F kombinierbar.

   -d

	Listet die Termine des aktuellen und der kommenden zwei Monate auf.
	Termine müssen in der Datei dates/dates.rc eingetragen werden.
	Beispiele finden sich in der Datei dates/example.rc
	Weitere Informationen findet man auch unter:
	https://www.gnu.org/software/gcal/manual/gcal.html

   -D [YYYY]

	listet die Termine für die kommenden 12 Monate auf.
	Bei optionaler Angabe einer Jahreszahl werden die Termine des angegebenen Jahres angezeigt.
	Die Jahreszahl muss als letztes Argument angegeben werden.
	Die Option -D ist mit den Optionen -C und -F kombinierbar.

   -e ARG YYYY [LÄNDERCODE]

	exportiert die Feiertage und/oder Termine eines angegeben Jahres in eine .ics-Datei.
	Benötigt weitere Angaben in Form eines Formats und einer Jahreszahl.
	Folgende Formate können angegeben werden:

	ics     - Exportiert Feiertage und Termine eines angegebenen Kalenderjahres in das .ics-Dateiformat.
	ics:h   - Exportiert nur die Feiertage eines angegebenen Kalenderjahres in das .ics-Dateiformat.
	ics:d   - Exportiert nur die Termine eines angegebenen Kalenderjahres in das .ics-Dateiformat.

	Es kann auch für die Formate ics und ics:h ein alternativer Ländercode angegeben werden,
	der nicht in der config-Datei definiert ist. Dieser wird dann anstelle eines Ländercodes aus der
	config-Datei übernommen.

   -E ARG NAME [VORNAME]

	Exportiert das Ergebnis der Adresssuche mit dem angegebenen Namen. Benötigt ein weiteres
	Argument in Form eines Formats. Folgende Formate können zur Zeit angegeben werden:

	vcf     - Standardformat für Adressdaten.
	          Die Ausgabe kann als klassische .vcf-Datei oder als QR-Code gewählt werden.
	messid  - Ausgabe einer MessengerID als QR-Code auf der Standardausgabe oder als Datei.

   -F ARG [YYYY]

	Ferientermine werden angezeigt. Benötigt eine der folgenden Angaben:
	1. Angabe eines Ländercodes aus Liste (-F l)
	2. l Mit 'l' werden die Ländercodes aufgelistet.

	Beispiel:
	DE_NW für Deutschland (Nordrhein-Westfalen)
	Bei optionaler Angabe einer Jahreszahl werden die Ferientermine des angegebenen Jahres angezeigt.
	Die Jahreszahl muss als letztes Argument angegeben werden.
	Die Option -F ist mit den Optionen -C und -D kombinierbar.

   -h

	ruft diese Hilfe auf.

   -H

	erstellt eine neue .hash.log-Datei in ${pathofaddress}

   -j

	zeigt den Inhalt der Notiz-Datei an.
	Notizen müssen in die Datei notes/jottings.txt eingetragen werden.

   -J

	Öffnet die Datei notes/jottings.txt in Editor nano zur Bearbeitung.

   -l ARG
   -l miss NAME

	listet verschiedene Dinge auf. Beonötigt ein weiteres Argument.
	file    - listet die Adressdatei auf.
	label   - listet die Label der eingebundenen Felder einer Adressdatei auf (Anschrift, PLZ, usw.). 
	miss    - listet die Felder EINES Datensatzes auf, die noch nicht mit Inhalt belegt sind.
	          (Notizen und Kontaktdaten sonstige (MessengerIDs) ausgenommen.)
	          Benötigt mindestens den Nachnamen.
	          Angabe des Vornamens ist optional, wenn nur ein Datensatz existiert.

   -m ARG NAME [VORNAME]

	ändert einzelne Elemente aus einem vcf-Datensatz. Benötigt eins der folgenden Argumente:
	mod     - Fügt eine neue Zeile zu einem bestehenden Datensatz hinzu oder ändert eine bestehende Zeile.
	del     - Löscht eine bestimmte Zeile aus einem bestehenden Datensatz.
	Zeitstempel wird aktualisiert.

	delmess - Löscht eine MessengerID aus Adressdatendatei.

   -n ARG

	nimmt einen neuen Datensatz in die Adressdatei auf.
	Eines der folgenden Argumente muss zusätzlich mit angegeben werden:
	briar    - Nimmt einen neuen Briar-Datensatz auf.
	jabber   - Nimmt einen neuen Jabber-Datensatz auf.
	jami     - Nimmt einen neuen Jami-Datensatz auf.
	mastodon - Nimmt einen neuen Mastodon-Datensatz auf.
	tox      - Nimmt einen neuen Tox-Datensatz auf.
	vcf      - Nimmt einen neuen Adress-Datensatz im vcf-Format auf.
	           Diese Datensätze bilden die Grundlage für diese Adressverwaltung.

   -r ARG

	Termine des aktuellen Tages an unterschiedliche Dienste übergeben.
	Eines der folgenden Argumente muss zusätzlich mit angegeben werden:
	mail    - Termine an eine E-Mail Adresse senden.
	          Es muss ein SMTP-Client wie zum Beispiel msmtp installiert sein.
	notify  - Termine als Benachrichtigung mit notify-send auf dem Desktop ausgeben.
	Für diese Option muss die Datei addressli.conf konfiguriert sein.

	Wenn man die Variable remind in der Datei addressli.conf auf "yes" setzt, aktiviert man
	die Terminerinnerung. Nach einer definierten Minutenzahl kann man sich Erinnerungen vor dem
	eigentlichen Beginn des Termins ausgeben lassen. Ändert man oft die Datei dates.rc, kann man die
	Änderungen auch mit einem Cron-Eintrag überwachen lassen. Näheres dazu weiter unten.
	Weitere Erläuterungen zur Konfiguration befinden sich auch in der Datei addressli.conf

   -s

	Synchronisation mit einem Server mittels scp. Die Datei .hash.log dient hier als Referenzdatei
	für die Synchronisation zwischen Client und Host.
	Bei Problemen kann man die Logdatei aufrufen mit:
	journalctl -r | grep 'addressli'
	Vor dem erstmaligen Ausführen der Synchronisation (Option -s) bitte die Dateien zwischen Client
	und Host 'von Hand' abgleichen und ggf. ein Backup der Daten machen.

   -u ARG

	Daten der Schulferien werden heruntergeladen/aktualisiert.
	Eines der folgenden Länderkürzel muss zusätzlich mit angegeben werden:
	at  - Österreich
	ch  - Schweiz
	de  - Deutschland
	all - Alle oben aufgeführten Länder

   -w

	Öffnet die Datei dates/dates.rc in Editor nano zur Bearbeitung.

   -W

	mit dieser Option kann man die Datei address.lst im Editor nano manuell bearbeiten.

Hinweis:
Mit folgender Zeile kann man address.lst "manuell" verschlüsseln:
ccencrypt "${pathofaddress}/address.lst"
Mit folgender Zeile kann man address.lst "manuell" entschlüsseln:
ccdecrypt "${pathofaddress}/address.lst.cpt"

Weitere Beispiele:

Autostart:
Beispiel 1:
Hat man das Gnome-Terminal, kann man dieses Programm zum Beispiel mit folgender Befehlszeile zu den
Startprogrammen hinzufügen:
gnome-terminal --full-screen -- bash -c 'addressli -sd; read -p "Einen schönen Tag noch! Fenster schließen mit [ENTER]"'
Beispiel 2 (Termine des Tages als Benachrichtigung anzeigen):
$0 -r notify

Cron:
Auch die Verwendung mit Cron ist möglich. Ggf. muss die Zeile [ -z "$SSH_AUTH_SOCK" ] && export SSH_AUTH_SOCK= ...
in der Datei addressli.conf komplettiert und einkommentiert werden.

Beispiel 1 (Synchronisation zu jeder vollen Stunde):
0 * * * * $0 -s

Beispiel 2 (Termine des Tages einmalig beim Start mit E-Mail verschicken):
@reboot $0 -r mail

Beispiele 3 und 4 (Überwachung der Datei dates.rc, um den Inhalt von Terminerinnerungen aktuell zu halten):
*/20 * * * * $0 -r notify remindupdate (Alle 20 Minuten werden die Termine des aktuellen Tages geprüft
                                        und ggf. an at-Dienst übergeben.)
*/20 * * * * $0 -r mail remindupdate   (Das Gleiche wie oben, nur für die Terminerinnerungen, die mit einer Mail
                                        verschickt werden.)

Beispiel 5 (Exportieren der Termindaten in den Evolution-Kalender-Ordner. Achtung: die PATH-Variable muss
bei dieser Schreibweise in der Crontab gesetzt sein!):
@reboot sleep 15 && cd /pfad/zum/evolution/calendar && addressli -e ics:d 2023 && addressli -e ics:d 2024
Zu beachten ist hier, dass die Datenintegration hier zur Zeit nur in eine Richtung funktioniert: addressli => Evolution
Außerdem muss der Kalender in Evolution noch einmalig hinzugefügt werden.

EOU
}

# *** VCF-Vorlage ***
# Hinweise zur Vorlage:
# BDAY Format yyyymmdd
# GEO dezimal dd.dddddd
# URL http://www.example.com
# EMAIL Weitere e-mails können mit PREF=2, PREF=3 usw. und entsp. TYPE-Bez. später hinzugefügt werden.
# Tel +??-????-??????
# NOTE (Notizen mit Zeilenumbrüchen) Halli\nHallo\nHallöle
# REV (Zeitstempel) 20210404T000000Z
# LANG (Sprache der Person) Beispiel: de-DE
vcfvorlage() {
cat <<EOV
BEGIN:VCARD
VERSION:4.0
N:${fill_nachname};${fill_vorname};;;
FN:${fill_vorname} ${fill_nachname}
BDAY:${fill_birthday}
TEL;TYPE=home,voice;VALUE=uri:tel:${fill_tel_home}
TEL;TYPE=home,cell;VALUE=uri:tel:${fill_mob_home}
ADR;TYPE=home;LABEL="${fill_strasse_home}\n${fill_plz_home} ${fill_ort_home}\n${fill_land_home}":;;${fill_strasse_home};${fill_ort_home};;${fill_plz_home};${fill_land_home}
GEO;TYPE=home:geo:${fill_lat_home},${fill_lon_home}
URL;TYPE=home:${fill_url_home}
EMAIL;PREF=1;TYPE=home:${fill_email_home1}
EMAIL;TYPE=home:${fill_email_home2}
ORG:${fill_firma};${fill_abteilung};${fill_beruf}
TEL;TYPE=work,voice;VALUE=uri:tel:${fill_tel_work}
TEL;TYPE=work,cell;VALUE=uri:tel:${fill_mob_work}
ADR;TYPE=work;LABEL="${fill_strasse_work}\n${fill_plz_work} ${fill_ort_work}\n${fill_land_work}":;;${fill_strasse_work};${fill_ort_work};;${fill_plz_work};${fill_land_work}
GEO;TYPE=work:geo:${fill_lat_work},${fill_lon_work}
URL;TYPE=work:${fill_url_work}
EMAIL;PREF=1;TYPE=work:${fill_email_work1}
EMAIL;TYPE=work:${fill_email_work2}
NOTE:${fill_note}
REV:$(date +%Y%m%dT%H%M%SZ)
LANG:${fill_lang}
END:VCARD
EOV
}

datenabfrage() {
# Nach- bzw. Vorname ist zwingend, damit Datensatz identifiziert werden kann.
if [ "$newdata" == "yes" ]; then
 read -p "Nachname: " fill_nachname
 while [ -z "$fill_nachname" ]; do
  read -p "Ungültiger Nachname! Bitte Nachnamen erneut eingeben: " fill_nachname
 done
 read -p "Vorname: " fill_vorname
 while [ -z "$fill_vorname" ]; do
  read -p "Ungültiger Vorame! Bitte Vornamen erneut eingeben: " fill_vorname
 done
 namesearchcontent="$(ccat ${pathofaddress}/address.lst.cpt)"
 namesearchresult="$(echo "$namesearchcontent" | grep -i "^N:${fill_nachname};${fill_vorname}")"
 if [ -n "$namesearchresult" ]; then
  echo "Datensatz existiert bereits. Vorgang wird abgebrochen."
  exit 1
 fi
fi
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "geburtstag" ]) && read -p "Geburtstag (yyyymmdd): " fill_birthday
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "tel_fest_priv" ]) && read -p "Telefon Festnetz (privat): " fill_tel_home
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "tel_mob_priv" ]) && read -p "Telefon mobil (privat): " fill_mob_home
if ([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "str_nr_priv" ]); then
 read -p "Straße und Hausnummer (privat): " fill_strasse_home
 read -p "Postleitzahl (privat): " fill_plz_home
 read -p "Wohnort (privat): " fill_ort_home
 read -p "Staat des privaten Wohnsitzes: " fill_land_home
fi
# Geo-URI (home) inkl. Formatüberprüfung
if ([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "geo_wohns_priv" ]); then
 read -p "Georafische Breite (lat) des priv. Wohnsitzes (dezimale Schreibweise; dd.dddddd): " fill_lat_home
 gradlathome="$(echo "$fill_lat_home" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 while [ -z "$(echo "$fill_lat_home" | egrep '^-*[[:digit:]]{1,2}\.[[:digit:]]*$')" -o "$gradlathome" -gt "90" ]; do
  echo "Ungültiges Format für Georafische Breite (lat)"
  read -p "Bitte erneut eingeben (dezimale Schreibweise; dd.dddddd): " fill_lat_home
  gradlathome="$(echo "$fill_lat_home" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 done
 read -p "Georafische Länge (lon) des priv. Wohnsitzes (dezimale Schreibweise; ddd.dddddd): " fill_lon_home
  gradlonhome="$(echo "$fill_lon_home" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 while [ -z "$(echo "$fill_lon_home" | egrep '^-*[[:digit:]]{1,3}\.[[:digit:]]*$')" -o "$gradlonhome" -gt "180" ]; do
  echo "Ungültiges Format für Georafische Länge (lon)"
  read -p "Bitte erneut eingeben (dezimale Schreibweise; ddd.dddddd): " fill_lon_home
  gradlonhome="$(echo "$fill_lon_home" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 done
fi
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "url_priv" ]) && read -p "URL (privat; Bsp.:http://www.example.com): " fill_url_home
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "email1_priv" ]) && read -p "Primäre E-mail (privat): " fill_email_home1
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "email2_priv" ]) && read -p "Weitere E-mail (privat): " fill_email_home2
if ([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "firma" ]); then
 read -p "Firma: " fill_firma
 read -p "Firmenabteilung: " fill_abteilung
 read -p "Berufsbezeichnung: " fill_beruf
fi
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "tel_fest_beruf" ]) && read -p "Telefon Festnetz (berufl.): " fill_tel_work
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "tel_mobil_beruf" ]) && read -p "Telefon mobil (berufl.): " fill_mob_work
if ([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "str_nr_beruf" ]); then
 read -p "Straße und Hausnummer (berufl.): " fill_strasse_work
 read -p "Postleitzahl (berufl.): " fill_plz_work
 read -p "Wohnort (berufl.): " fill_ort_work
 read -p "Staat des beruflichen Wohnsitzes: " fill_land_work
fi
# Geo-URI (work) inkl. Formatüberprüfung
if ([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "geo_wohns_beruf" ]); then
 read -p "Georafische Breite (lat) des berufl. Wohnsitzes (dezimale Schreibweise; dd.dddddd): " fill_lat_work
 gradlatwork="$(echo "$fill_lat_work" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 while [ -z "$(echo "$fill_lat_work" | egrep '^-*[[:digit:]]{1,2}\.[[:digit:]]*$')" -o "$gradlatwork" -gt "90" ]; do
  echo "Ungültiges Format für Georafische Breite (lat)"
  read -p "Bitte erneut eingeben (dezimale Schreibweise; dd.dddddd): " fill_lat_work
  gradlatwork="$(echo "$fill_lat_work" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 done
 read -p "Georafische Länge (lon) des berufl. Wohnsitzes (dezimale Schreibweise; ddd.dddddd): " fill_lon_work
 gradlonwork="$(echo "$fill_lon_work" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 while [ -z "$(echo "$fill_lon_work" | egrep '^-*[[:digit:]]{1,3}\.[[:digit:]]*$')" -o "$gradlonwork" -gt "180" ]; do
  echo "Ungültiges Format für Georafische Länge (lon)"
  read -p "Bitte erneut eingeben (dezimale Schreibweise; ddd.dddddd): " fill_lon_work
  gradlonwork="$(echo "$fill_lon_work" | sed 's/^-*\([[:digit:]]*\)\.[[:digit:]]*/\1/')"
 done
fi
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "url_beruf" ]) && read -p "URL (berufl.; Bsp.:http://www.example.com): " fill_url_work
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "email1_beruf" ]) && read -p "Primäre E-mail (berufl.): " fill_email_work1
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "email2_beruf" ]) && read -p "Weitere E-mail (berufl.): " fill_email_work2
[ "$newdata" == "yes" ] && read -p "Notizen (Eventuelle Zeilenumbrüche mit \\n angeben): " fill_note
[ "$modifymodus" == "yes" -a "$modtype" == "notiz" ] && read -p "Notizen: " fill_note
([ "$newdata" == "yes" ] || [ "$modifymodus" == "yes" -a "$modtype" == "sprache" ]) && read -p "Sprache der Person (Beispiel: de-DE): " fill_lang
}
adrprint1() {
    if ([ "$showlabel" == "yes" ] || [ -n "${nachname}" -o -n "${vorname}" -o -n "$birthday" -o -n "$muttersprache" ]); then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Persönliche Daten"
    fi
    [ -n "${nachname}" -o "$showlabel" == "yes" ] && printf 'Nachname             : %0s\n' "${nachname^}"
    [ -n "${vorname}" -o "$showlabel" == "yes" ] && printf 'Vorname              : %0s\n' "${vorname^}"
    [ -n "${birthday}" -o "$showlabel" == "yes" ] && printf 'Geburtstag           : %0s\n' "$birthday"
    [ -n "${muttersprache}" -o "$showlabel" == "yes" ] && printf 'Sprache              : %0s\n' "$muttersprache"

    if ([ "$showlabel" == "yes" ] || [ -n "$adr_home_strasse" -o -n "$adr_home_plz" -o -n "$adr_home_ort" -o -n "$adr_home_land" -o -n "$geo_uri_home" ]); then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Adresse privat"
    fi
    [ -n "$adr_home_strasse" -o "$showlabel" == "yes" ] && printf 'Straße               : %0s\n' "$adr_home_strasse"
    ([ "$showlabel" == "yes" ] || [ -n "$adr_home_plz" -o -n "$adr_home_ort" ]) && printf 'PLZ/Ort              : %0s %0s\n' "$adr_home_plz" "$adr_home_ort"
    [ -n "$adr_home_land" -o "$showlabel" == "yes" ] && printf 'Land                 : %0s\n' "$adr_home_land"
    if [ -n "$geo_uri_home" -o "$showlabel" == "yes" ]; then
     geolathome="$(echo "${geo_uri_home}" | sed 's/geo:\(.*\),.*/\1/')"
     geolonhome="$(echo "${geo_uri_home}" | sed 's/geo:.*,\(.*\)/\1/')"
     osmurlhome="https://www.openstreetmap.org/?mlat=${geolathome}&mlon=${geolonhome}#map=15/${geolathome}/${geolonhome}"
     printf 'Geo-URI              : %0s\n' "${geo_uri_home}"
     [ ! "$showlabel" == "yes" ] && printf 'OSM-Link             : %0s\n' "$osmurlhome"
    fi      
    if ([ "$showlabel" == "yes" ] || [ -n "$con_tel_home" -o -n "$con_mob_home" -o -n "$con_website_home" -o -n "$con_email_home" ]); then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Kontaktdaten privat"
    fi
    [ -n "$con_tel_home" -o "$showlabel" == "yes" ] && printf 'Telefon              : %0s\n' "$con_tel_home"
    [ -n "$con_mob_home" -o "$showlabel" == "yes" ] && printf 'Telefon mobil        : %0s\n' "$con_mob_home"
    [ -n "$con_website_home" -o "$showlabel" == "yes" ] && printf 'Homepage             : %0s\n' "$con_website_home"
    [ -n "$con_email_home" -o "$showlabel" == "yes" ] && printf 'E-mail               : %0s\n' "$con_email_home"
   
    if ([ "$showlabel" == "yes" ] || [ -n "$adr_work_org" -o -n "$org_work_abt" -o -n "$adr_work_strasse" -o -n "$adr_work_plz" -o -n "$adr_work_ort" -o -n "$adr_work_land" -o -n "$org_work_beruf" -o -n "$geo_uri_work" ]); then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Adresse Arbeit"
    fi
    [ -n "$adr_work_org" -o "$showlabel" == "yes" ] && printf 'Organisation         : %0s\n' "$adr_work_org"
    [ -n "$org_work_abt" -o "$showlabel" == "yes" ] && printf 'Abteilung            : %0s\n' "$org_work_abt"
    [ -n "$adr_work_strasse" -o "$showlabel" == "yes" ] && printf 'Straße               : %0s\n' "$adr_work_strasse"
    ([ "$showlabel" == "yes" ] || [ -n "$adr_work_plz" -o -n "$adr_work_ort" ]) && printf 'PLZ/Ort              : %0s %0s\n' "$adr_work_plz" "$adr_work_ort"
    [ -n "$adr_work_land" -o "$showlabel" == "yes" ] && printf 'Land                 : %0s\n' "$adr_work_land"
    [ -n "$org_work_beruf" -o "$showlabel" == "yes" ] && printf 'Beruf                : %0s\n' "$org_work_beruf"
    if [ -n "$geo_uri_work" -o "$showlabel" == "yes" ]; then
     geolatwork="$(echo "${geo_uri_work}" | sed 's/geo:\(.*\),.*/\1/')"
     geolonwork="$(echo "${geo_uri_work}" | sed 's/geo:.*,\(.*\)/\1/')"
     osmurlwork="https://www.openstreetmap.org/?mlat=${geolatwork}&mlon=${geolonwork}#map=15/${geolatwork}/${geolonwork}"
     printf 'Geo-URI              : %0s\n' "${geo_uri_work}"
     [ ! "$showlabel" == "yes" ] && printf 'OSM-Link             : %0s\n' "$osmurlwork"
    fi   
    if ([ "$showlabel" == "yes" ] || [ -n "$con_tel_work" -o -n "$con_mob_work" -o -n "$con_website_work" -o -n "$con_email_work" ]); then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Kontaktdaten Arbeit"
    fi
    [ -n "$con_tel_work" -o "$showlabel" == "yes" ] && printf 'Telefon              : %0s\n' "$con_tel_work"
    [ -n "$con_mob_work" -o "$showlabel" == "yes" ] && printf 'Telefon mobil        : %0s\n' "$con_mob_work"
    [ -n "$con_website_work" -o "$showlabel" == "yes" ] && printf 'Homepage             : %0s\n' "$con_website_work"
    [ -n "$con_email_work" -o "$showlabel" == "yes" ] && printf 'E-mail               : %0s\n' "$con_email_work"

    # MessDef2
    if ([ "$showlabel" == "yes" ] || [ -n "$briarcontent" -o -n "$jabbercontent" -o -n "$jamicontent" -o -n "$mastodoncontent" -o -n "$toxcontent" ]); then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Kontaktdaten sonstige"
     [ "$showlabel" == "yes" ] && echo "MessengerIDs; etc."
    fi
}
adrprint2() {
    if [ -n "$sonstiges" -o "$showlabel" == "yes" ]; then
     let printcounter++
     echo -e "\n${vcardcheck}.${printcounter} Sonstiges"
     echo -e "$sonstiges" | sed 's/^/                       /;1s/^ */Notizen              : /'
    fi
}
gcalcheck() {
    if [ -z "$(type -p gcal)" ]; then
     echo "Das Programm gcal ist nicht installiert. Skript wird abgebrochen!"
     exit 1
    fi
}
datefilecheck() {
    if [ ! -e "${pathofaddress}/dates/dates.rc" ]; then
     echo -e "Ressource-Datei ${pathofaddress}/dates/dates.rc existiert nicht. Bitte erst anlegen.\nEine Beispieldatei finden Sie unter:\nhttps://raw.githubusercontent.com/CarstenHa/addressli/master/dates/example.rc\nSkript wird abgebrochen!"
     exit 1
    else
     datefile="${pathofaddress}/dates/dates.rc"
    fi
}
notefilecheck() {
    if [ ! -e "${pathofaddress}/notes/jottings.txt" ]; then
     echo -e "Notiz-Datei ${pathofaddress}/notes/jottings.txt existiert nicht. Bitte erst anlegen.\nEine Beispieldatei finden Sie unter:\nhttps://raw.githubusercontent.com/CarstenHa/addressli/master/notes/example.txt\nSkript wird abgebrochen!"
     exit 1
    else
     notefile="${pathofaddress}/notes/jottings.txt"
    fi
}
checksum() {
    datefilecheck
    notefilecheck
    md5sum "${pathofaddress}/address.lst.cpt" 2>/dev/null
    md5sum "$datefile" 2>/dev/null
    md5sum "$notefile" 2>/dev/null
}
filesync() {
    if [ "$async" == "yes" ]; then

     unset syncerr
     echo "**** Synchronisation der Daten mit dem Server ${sshuserhost#*@} ****"
     if [ ! "$(ping -c 1 "${sshuserhost#*@}" &>/dev/null; echo $?)" == 0 ]; then

      logger -s --id=$$ "${0}: Server ${sshuserhost#*@} nicht erreichbar."
      # Diese Variable wird benötigt für Funktion adrdecrypt und Option -w
      # Damit vor der Bearbeitung einer Datei noch die Möglichkeit zum Abbruch besteht.
      syncerr="1"

     else

      listoffiles=(address.lst.cpt dates.rc jottings.txt)

      for file in ${listoffiles[@]}; do

       oldhash="$(cat "${pathofaddress}/.hash.log" | grep "$file" | cut -f1 -d' ')"

       newcheck="$(checksum | grep "$file")"
       newhash="$(echo "$newcheck" | cut -f1 -d' ')"
       localdirname="$(echo "$newcheck" | grep "$file" | tr -s ' ' | cut -f2 -d' ')"
       localdir="$(dirname "${localdirname}")"
       localmoddate="$(stat --format=%Y "${localdirname}")"

       # Prüfsummen der Dateien auf dem Server werden ermittelt.
       [ -z "$remotehashraw" ] && remotehashraw="$(ssh -p "$sshport" -i "$sshkeyfile" "$sshuserhost" "md5sum ${remoteaddrfile} 2>/dev/null; md5sum ${remotedatefile} 2>/dev/null; md5sum ${remotenotefile} 2>/dev/null")"
       remotehash="$(echo "$remotehashraw" | grep "$file" | cut -f1 -d' ')"
       remotedirname="$(echo "$remotehashraw" | grep "$file" | tr -s ' ' | cut -f2 -d' ')"
       remotedir="$(dirname "${remotedirname}")"
       remotemoddate="$(ssh -p "$sshport" -i "$sshkeyfile" "$sshuserhost" 'stat --format=%Y '"${remotedirname}"'')"

       if [ "$oldhash" != "$newhash" -a "$oldhash" != "$remotehash" ]; then

        logger -s --id=$$ "Es gibt einen Konflikt mit der Datei ${file}."
        if [ "${file}" == "dates.rc" ]; then
         echo "                                      local < = > remote"
         diff -y --width=100 --suppress-common-lines "${pathofaddress}/dates/dates.rc" <(ssh -p "$sshport" -i "$sshkeyfile" "$sshuserhost" "cat ${remotedatefile}")
        elif [ "${file}" == "jottings.txt" ]; then
         echo "                                      local < = > remote"
         diff -y --width=100 --suppress-common-lines "${pathofaddress}/notes/jottings.txt" <(ssh -p "$sshport" -i "$sshkeyfile" "$sshuserhost" "cat ${remotenotefile}")
        fi
        echo "Problemlösungen:"
        echo -e "Option -s ausführen.\nDateien manuell ändern und abgleichen und anschließend ggf. die Datei .hash.log löschen."
        syncerr="1"

       elif [ "$oldhash" == "$newhash" -a "$oldhash" == "$remotehash" ]; then

        echo "${0}: Keine Veränderung an Datei ${file} festgestellt." | tee >(logger --id=$$)

       # Bearbeitete Datei (newhash) ist die gleiche, wie die, die zuletzt synchronisiert (oldhash) wurde.
       # aber die remote-Datei (remotehash) ist NICHT die gleiche, wie die, die zuletzt synchronisiert (oldhash) wurde.
       # ... -ge ... ist wichtig, wenn die Datei address.lst.cpt mit -w geöffnet, aber nicht geändert
       # wird, ändert sich der Hash-Wert, aber nicht der Zeitstempel.
       elif [ "$oldhash" == "$newhash" -a "$oldhash" != "$remotehash" -a "$remotemoddate" -ge "$localmoddate" ]; then
        echo "Download der Datei ${file} vom Server ${sshuserhost} ..."
        scp -pP "$sshport" -i "$sshkeyfile" "${sshuserhost}:/${remotedir}/${file}" "${localdir}/"
        exitdown=$?
        if [ "$exitdown" == 0 ]; then
         checksum >"${pathofaddress}/.hash.log"
         echo "${0}: Download der Datei ${file} wurde erfolgreich durchgeführt." | tee >(logger --id=$$)
        else
         logger -s --id=$$ "Fehler beim Download der Datei ${file}."
         syncerr="1"
        fi

       # Die remote-Datei (remotehash) ist die gleiche, wie die, die zuletzt synchronisiert (oldhash) wurde.
       # aber die bearbeitete Datei (newhash) ist NICHT die gleiche, wie die, die zuletzt synchronisiert (oldhash) wurde.
       # ... -ge ... ist wichtig, wenn die Datei address.lst.cpt mit -w geöffnet, aber nicht geändert
       # wird, ändert sich der Hash-Wert, aber nicht der Zeitstempel.
       elif [ "$oldhash" != "$newhash" -a "$oldhash" == "$remotehash" -a "$localmoddate" -ge "$remotemoddate" ]; then
        echo "Upload der Datei ${file} zum Server ${sshuserhost} ..."
        scp -pP "$sshport" -i "$sshkeyfile" "${localdir}/${file}" "${sshuserhost}:${remotedir}/"
        exitup=$?
        if [ "$exitup" == 0 ]; then
         checksum >"${pathofaddress}/.hash.log"
         echo "${0}: Upload der Datei ${file} wurde erfolgreich durchgeführt." | tee >(logger --id=$$)
        else
         logger -s --id=$$ "Fehler beim Upload der Datei ${file}."
         syncerr="1"
        fi

       else

        logger -s --id=$$ "Es gibt einen undefinierten Konflikt mit der Datei ${file}."
        printf 'Dateiame                      : %-30s\n' "${file}"
        printf 'Server                        : %-30s\n' "${sshuserhost#*@}"
        printf "Alter Hash-Wert aus .hash.log : %-30s\n" "${oldhash}"
        printf 'Hash-Wert der lokalen Datei   : %-30s\n' "${newhash}"
        printf 'Hash-Wert der Server-Datei    : %-30s\n' "${remotehash}"
        printf 'Zeitstempel der lokalen Datei : %-30d\n' "${localmoddate}"
        printf 'Zeitstempel der Server-Datei  : %-30d\n' "${remotemoddate}"
        syncerr="1"
        exit 1

       fi

      done

     # Ende der Verzweigung (ping)
     fi

    else
     echo "Keine Synchronisation in ${conffile} eingerichtet."
    fi
}
adrdecrypt() {
    if [ "$modifysync" == "yes" ]; then
     filesync
     [ "$syncerr" == 1 ] && read -p "Ohne Synchronisation weiter mit [ENTER]. Abbruch mit [STRG]+[C]"
    fi
    echo "Adressdatei wird gesichert und zur Bearbeitung entschlüsselt ..."
    cp -iv "${pathofaddress}/address.lst.cpt" "${pathofaddress}/backupfiles/`date +%Y%m%d%H%M%S`_address.lst.cpt"
    read -sp "Bitte Passwort eingeben: " mysecpassw
    export mysecpassw
    ccdecrypt -E mysecpassw "${pathofaddress}/address.lst.cpt"
    while [ ! "$?" == "0" ]; do
     read -sp "Fehler beim Entschlüsseln der Adressdatei. Bitte Passwort erneut eingeben: " mysecpassw
     export mysecpassw
     ccdecrypt -E mysecpassw "${pathofaddress}/address.lst.cpt"
    done
}
adrencrypt() {
    echo "Die Adressdatei wird wieder verschlüsselt ..."
    ccencrypt -E mysecpassw "${pathofaddress}/address.lst"
    if [ ! "$?" == "0" ]; then
     echo "Fehler beim Verschlüsseln der Adressdatei. Programm wird abgebrochen!"
     echo "Datei bitte manuell verschlüsseln mit: ccencrypt ${pathofaddress}/address.lst"
     exit 1
    fi
    [ "$modifysync" == "yes" ] && filesync
}
holiupdate() {
    # Ländercodes müssen ISO-3166-1 bwz. ISO-3166-2 entsprechen.
    unset dlerror
    echo "Daten der Schulferien werden geprüft und ggf. heruntergeladen ..."
    repourl="https://github.com/openpotato/openholidaysapi.data"
    wget -Nc -t 3 --progress=bar -P "${pathofaddress}/holidays/" "${repourl}/raw/develop/LICENSE" && \
    licensepath="${pathofaddress}/holidays/LICENSE" || dlerror="yes"
    if [ "$dlerror" == "yes" ]; then
     echo "Fehler beim Herunterladen der Daten. Skript wird abgebrochen."
     exit 1
    else
     echo -e "Quelle : ${repourl}\n         Lizenz siehe ${licensepath}" >"${pathofaddress}/holidays/SOURCE"
    fi
    wget -Nc -t 3 --progress=bar -P "${pathofaddress}/holidays" "${repourl}/raw/develop/src/countries.csv"
    for country in ${countrylist[@]}; do
     unset hfilename
     [ ! -d "${pathofaddress}/holidays/${country}" ] && mkdir -v "${pathofaddress}/holidays/${country}"
     if [ "$country" == "at" ]; then
      hfilename="holidays.school.csv"
     elif [ "$country" == "ch" ]; then
      hfilename="holidays.school.{ag,ai,ar,be,bl,bs,fr,ge,gl,gr,ju,lu,ne,nw,ow,sg,sh,so,sz,tg,ti,ur,vd,vs,zg,zh}.csv"
     elif [ "$country" == "de" ]; then
      hfilename="holidays.school.{bb,be,bw,by,hb,he,hh,mv,ni,nw,rp,sh,sl,sn,st,th}.csv"
     fi
     wget -Nc -t 3 --progress=bar -P "${pathofaddress}/holidays/${country}" "${repourl}/raw/develop/src/${country}/subdivisions.csv"
     if [ -n "$hfilename" ]; then
      wgetcomm="wget -Nc -t 3 --progress=bar -P ${pathofaddress}/holidays/${country}"
      urlpath="${repourl}/raw/develop/src/${country}/holidays/${hfilename}"
      source <(echo "${wgetcomm} ${urlpath} || dlerror=yes")
      echo "Stand  : $(date '+%d.%m.%Y')" >"${pathofaddress}/holidays/${country}/timestamp.log"
     fi
    done
    [ "$dlerror" == "yes" ] && echo "Es gab Probleme beim Herunterladen der Daten."
}
# ********** Funktionen - Ende  **********

[ ! -e "${pathofaddress}/.hash.log" -o -z "$(grep "${pathofaddress}" "${pathofaddress}/.hash.log" 2>/dev/null)" ] && checksum >"${pathofaddress}/.hash.log"

while getopts cC:dDe:E:F:hHjJl:m:n:r:su:wW opt

do 
 case $opt in

  c) gcalcheck
     gcal -K
     echo ""
     exit
  ;;

  C) gcalcheck
     if ! [[ "$OPTARG" =~ ^[[:alpha:]][[:alpha:]]$ || "$OPTARG" =~ ^[[:alpha:]][[:alpha:]]_[[:alpha:]][[:alpha:]]$ || "$OPTARG" =~ ^[l?]$ ]]; then
      usage
      echo "Ungültiges Argument (Option -C). Skript wird abgebrochen!"
      exit 1
     else
      optccal="yes"
     fi
     if [ "$OPTARG" == "l" ]; then
      gcal --usage=cc-holidays
      onlychelp="yes"
     else
      causwahl="$OPTARG"
     fi
  ;;

  d) gcalcheck
     datefilecheck
     gcal -K -f "$datefile" -c .+
     echo ""
     exit
  ;;

  D) gcalcheck
     datefilecheck
     optdcal="yes"
  ;;

  e) expformat="$OPTARG"

     # ***** Exportieren von Kalender- und Termindaten *****
     if [ "$expformat" == "ics:h" -o "$expformat" == "ics:d" -o "$expformat" == "ics" ]; then

      gcalcheck

      shift $(("$OPTIND"-1))

      adrstring="$@"
      for arg in ${adrstring[@]}; do
       if [[ "$arg" == [0-9][0-9][0-9][0-9] ]]; then
        ejahr="$arg"
       elif [[ "$arg" == [[:alpha:]][[:alpha:]] || "$arg" == [[:alpha:]][[:alpha:]]_[[:alpha:]][[:alpha:]] ]]; then
        eauswahl="$arg"
       fi
      done

      while [[ ! "$ejahr" == [0-9][0-9][0-9][0-9] ]]; do
       read -p "Bitte ein Jahr angeben (yyyy): " ejahr
      done

      # *** Termindaten ***
      if [ "$expformat" == "ics:d" -o "$expformat" == "ics" ]; then

       datefilecheck
       calcontent="$(gcal -K -u -f "$datefile" --date-format="%>04*Y-%>02*M-%1%>02*D%2" --highlighting=no "$ejahr" | sed '1,3d')"
       tmptimefile=$(mktemp)

       icscontent="$(
                     while read -r cline; do

                      unset startzeit
                      unset endezeit
                      datedat="$(echo "$cline" | sed -n 's/^\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\).*/\1\2\3/p')"

                      # Uhrzeit analysieren
                      uhrzeit="$(echo "$cline" | egrep -o '[0-9]{2}:[0-9]{2}' | sort -n)"
                      anzzeiten="$(echo "$uhrzeit" | sed '/^$/d' | wc -l)"
                      if [ "$anzzeiten" != 0 ]; then
                       startzeit="$(echo "$uhrzeit" | sed -n '1p' | sed 's/://')"$'00'
                       endezeit="$(echo "$uhrzeit" | sed -n '$p' | sed 's/://')"$'00'
                       [ "$anzzeiten" -gt 2 ] && echo "$cline" >>"$tmptimefile"
                       if [ "$endezeit" -gt 240000 -o "$startzeit" -gt 240000 ]; then
                        echo "Ungültiges Uhrzeitformat: ${cline}"
                        exit 1
                       fi
                      fi

                      # Folgende Variable wird benötigt für:
                      # Enddatum eines ganztägigen Termins oder eine Zeit, die um 24:00 endet.
                      tommorrowis="$(($(date -d "$datedat" +"%s") + 86400))"
                      echo "BEGIN:VEVENT"
                      # Beschreibung des Termins
                      echo "SUMMARY:$(echo "$cline" | sed -n 's/^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}: \(.*\)/\1/p')"

                      # Wenn Uhrzeit ermittelt wurde, werden diese eingetragen,
                      # ansonsten ganztägiger Termin
                      if [ -n "$startzeit" -a -n "$endezeit" ]; then
                       echo "DTSTART:${datedat}T${startzeit}"
                       if [ "$endezeit" == 240000 ]; then
                        echo "DTEND:$(date -d @$tommorrowis +%Y%m%d)T000000"
                       else
                        echo "DTEND:${datedat}T${endezeit}"
                       fi
                      else
                       echo "DTSTART;VALUE=DATE:${datedat}"
                       echo "DTEND;VALUE=DATE:$(date -d @$tommorrowis +%Y%m%d)"
                      fi
                      echo "END:VEVENT"

                     done <<<"$calcontent"
                    )"

       if [ "$(stat --format=%s "$tmptimefile")" != 0 ]; then
        echo "Hinweis: Folgende Zeilen haben mehrere Zeitangaben:"
        cat "$tmptimefile"
        echo -e "Es werden die frühesten/spätesten Angaben verwendet.\n"
       fi
       rm -f "$tmptimefile"

      fi

      # *** Kalenderdaten ***
      if [ "$expformat" == "ics:h" -o "$expformat" == "ics" ]; then

       econtent() {
        for ec in ${countrycodes[@]}; do
         echo "$ec"
        done | nl
       }
       exdays() {
         if [ -n "$excludedays" ]; then
          for excd in "${excludedays[@]}"; do
           callinenr+="$(echo "$calcontent" | grep -ni "$excd" | grep -o "^[0-9]*"),"
           calcontent="$(echo "$calcontent" | sed "/${excd}/d")"
          done
         fi
       }

       while [ -z "$eauswahl" ]; do
        econtent
        read -p "Bitte Ländercode auswählen: " eland
        eauswahl="$(econtent | grep "$eland" | sed 's/^ *//' | cut -f2)"
       done
       if [ -n "$extholidays" ]; then

        calcontent="$(gcal -u -K -q${eauswahl} -H no --holiday-list --"$extholidays" --date-format="%>04*Y-%>02*M-%1%>02*D%2" "$ejahr")"
        # Abbruch bei ungültigem Ländercode.
        [ $? -gt 0 ] && exit
        # Doppelte Tage werden rausgefiltert.
        daylist="$(gcal -u -K -q${eauswahl} -H no --holiday-list --"$extholidays"  "$ejahr" | grep -o '[+-][0-9]* [[:alnum:]]*$' | uniq -d)"
        extholidaysabbr="$(gcal --holiday-list --"$extholidays" | grep -o '(.*)' | uniq | sed 's/[()]//g')"
        [ -n "$extholidaysabbr" ] && while read -r oneday; do
                                      calcontent="$(echo "$calcontent" | sed '
                                                     /('"$extholidaysabbr"').*'"$oneday"'/d
                                                  ')"
                                     done <<<"$daylist"

        # Aus config-Datei definierte Kalendereinträge werden gelöscht.
        exdays

       else

        calcontent="$(gcal -u -K -q"$eauswahl" -H no --holiday-list --date-format="%>04*Y-%>02*M-%1%>02*D%2" "$ejahr")"
        exdays

       fi

       calcontent="$(echo "$calcontent" | sed '
                                               1,3d
                                               s/ =.*$//
                                               s/^\(.*\) ([^)]*) */\1@/1
                                               s/ \([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\)/@\1/
                                              ')"

       icscontent2="$(while read -r cline; do
                      echo "BEGIN:VEVENT"
                      echo "SUMMARY:$(echo "$cline" | cut -f1 -d@)"
                      echo "DTSTART;VALUE=DATE:$(echo "$cline" | cut -f3 -d@ | sed 's/-//g')"
                      tommorrowis="$(($(date -d "$(echo "$cline" | cut -f3 -d@)" +"%s") + 86400))"
                      echo "DTEND;VALUE=DATE:$(date -d @$tommorrowis +%Y%m%d)"
                      if [ "$(echo "$cline" | cut -f2 -d@)" == "+" ]; then
                       echo "DESCRIPTION:Feiertag"
                      fi
                      echo "END:VEVENT"
                     done <<<"$calcontent"
                    )"

      fi

      # Dateinamen werden definiert
      if [ "$expformat" == "ics:h" ]; then
       expfilename="feiertage_${eauswahl,,}_${ejahr}.ics"
      elif [ "$expformat" == "ics:d" ]; then
       expfilename="termine_${ejahr}.ics"
      elif [ "$expformat" == "ics" ]; then
       expfilename="feiertage_${eauswahl,,}_und_termine_${ejahr}.ics"
      fi

      # *** Erstellung der .ics-Datei ***
      echo "BEGIN:VCALENDAR" >./"$expfilename"
      echo "VERSION:2.0" >>./"$expfilename"
      [ -n "$icscontent" ] && echo "$icscontent" >>./"$expfilename"
      [ -n "$icscontent2" ] && echo "$icscontent2" >>./"$expfilename"
      echo "END:VCALENDAR" >>./"$expfilename"
      echo "Datei ${expfilename} wurde erstellt und befindet sich im Ordner ${PWD}."

     else

      echo "${expformat} ist nicht definiert."
      exit 1

     fi

    exit
  ;;

  E) if [ "$OPTARG" == "vcf" ]; then
      echo "Daten werden als vcf exportiert"
      exportmodus="vcfformat"
      read -p "Soll in [v]cf-Datei oder in [Q]R-Code exportiert werden? " vcfexport
      while true; do
        case "$vcfexport" in
          v|V) vcftype="vcf"
               read -p "Bitte Dateinamen der angeben (Suffix .vcf wird automatisch hinzugefügt): " vcffilename
                  filesuffix="${vcffilename##*.}"
                  if [ ! "$filesuffix" == "vcf" ]; then
                   vcffilename+=".vcf"
                  fi
                  if [ -e ./"$vcffilename" ]; then
                   echo "Datei existiert bereits."
                   read -p "[u]eberschreiben oder [a]bbrechen? " delfileanswer
                   while true; do
                    case "$delfileanswer" in
                      u|U|"") rm -f ./"$vcffilename"
                       break
                       ;;
                      a|A) exit
                       ;;
                      *) echo "Fehlerhafte Eingabe!"
                       ;;
                    esac
                   done
                  fi
           break
           ;;
          q|Q) vcftype="qr"
           break
           ;;
          *) echo "Fehlerhafte Eingabe!"
           ;;
        esac
      done
     # Ausgabe auf der Standardasgabe des Terminals.
     elif [ "$OPTARG" == "messid" ]; then
      exportmodus="qrcode"
     else
      echo "Ungültige Option (${OPTARG}). Exportieren der Daten nicht möglich."
      exit 1
     fi

     # Das shiften ist wichtig, damit die Namen später korrekt ausgewertet werden.
     shift $(("$OPTIND"-1))
  ;;

  F) # Ausgabe der Ferientermine
     if ! [[ "$OPTARG" =~ ^[[:alpha:]][[:alpha:]]$ || "$OPTARG" =~ ^[[:alpha:]][[:alpha:]]_[[:alpha:]][[:alpha:]]$ || "$OPTARG" =~ ^[l]$ ]]; then
      usage
      echo "Ungültiges Argument (Option -F). Skript wird abgebrochen!"
      exit 1
     else
      optfcal="yes"
     fi
     fkuerzel="${OPTARG,,}"
     fkuerzelc="${fkuerzel%%_*}"
     fkuerzels="${fkuerzel##*_}"
     if [ "$fkuerzelc" == "at" -a -e "${pathofaddress}/holidays/${fkuerzelc}/holidays.school.csv" ]; then
      # Variable leeren ist wichtig für weiteres Vorgehen.
      fkuerzels=""
      fpath="${pathofaddress}/holidays/${fkuerzelc}/holidays.school.csv"
     elif [ -e "${pathofaddress}/holidays/${fkuerzelc}/holidays.school.${fkuerzels}.csv" ]; then
      fpath="${pathofaddress}/holidays/${fkuerzelc}/holidays.school.${fkuerzels}.csv"
     elif [ "$fkuerzel" == "l" ]; then
      onlyfhelp="yes"
     fi
  ;;

  h) usage
     exit
  ;;

  H) # Neue .hash.log-Datei erstellen.
     if [ -e "${pathofaddress}/.hash.log" ]; then
      echo "Sicherung der alten Datei wird erstellt."
      cp -iv "${pathofaddress}/.hash.log" "${pathofaddress}/backupfiles/`date +%Y%m%d%H%M%S`_hash.log"
     fi
     checksum >"${pathofaddress}/.hash.log" && echo "Neue Prüfsummendatei ${pathofaddress}/.hash.log wurde erfolgreich erstellt."
     exit
  ;;

  j) notefilecheck
     cat "$notefile"
     exit
  ;;

  J) notefilecheck
     if [ "$modifysync" == "yes" ]; then
      filesync
      [ "$syncerr" == 1 ] && read -p "Ohne Synchronisation weiter mit [ENTER]. Abbruch mit [STRG]+[C]"
     fi
     nano "$notefile"
     [ "$modifysync" == "yes" ] && filesync
     exit
  ;;

  l) if [ "$OPTARG" == "file" ]; then
      ccat ${pathofaddress}/address.lst.cpt
     elif [ "$OPTARG" == "label" ]; then
      showlabel="yes"
      vcardcheck=1
      onlylabel="$(adrprint1)"$'\n'
      onlylabel+="$(adrprint2)"
      labellist1="$(echo "$onlylabel" | sed '/:/s/^\(.\{21\}\).*/  \1/;/^MessengerIDs/s/^/  /;s/^[[:digit:]]*\.[[:digit:]]* \(.*$\)/* \1 */')"
      echo "$labellist1"
      echo ""
     elif [ "$OPTARG" == "miss" ]; then
      misslabel="yes"
      showlabel="yes"
      vcardcheck=1
      onlylabel="$(adrprint1)"
      onlylabel+="$(adrprint2)"
      labellist1="$(echo "$onlylabel" | sed 's/^\(.*\) *:.*/\1/;s/^[[:digit:]]*\.[[:digit:]]* \(.*$\)/* \1 */;/^* Kontaktdaten sonstige/,$d')"
      # Wichtig die Variablen hier zu löschen!
      unset showlabel
      unset vcardcheck
      shift $(("$OPTIND"-1))
      break
     else
      usage
      echo "Ungültige Angabe"
     fi
     exit
  ;;

  m) if [ "$OPTARG" == "del" -o "$OPTARG" == "mod" ]; then

       modifymodus="yes"

       allmodtype=(geburtstag tel_fest_priv tel_mob_priv str_nr_priv geo_wohns_priv url_priv email1_priv email2_priv firma tel_fest_beruf tel_mobil_beruf str_nr_beruf geo_wohns_beruf url_beruf email1_beruf email2_beruf notiz sprache)
       arraylist="$(echo "${allmodtype[@]}" | tr ' ' '\n' | sed '
                                                                 s/_/ /g
                                                                 s/\(\<.\)/\U\1/g
                                                                 s/Str Nr Priv/Straße,Hausnummer,PLZ und Ort Priv/
                                                                 s/Geo Wohns Priv/Geokoordinaten Wohnsitz Priv/
                                                                 s/Str Nr Beruf/Straße,Hausnummer,PLZ und Ort Beruf/
                                                                 s/Geo Wohns Beruf/Geokoordinaten Wohnsitz Beruf/
                                                                 s/ Beruf/ berufl./g
                                                                 s/\(Firma\)/\1, Abteilung und Berufsbezeichnung/
                                                                 s/ Fest / Festnetz /g
                                                                 s/ Mob / Mobil /g
                                                                 s/ Priv/ Privat/g
                                                                 s/Str /Straße /g
                                                                 s/Tel /Telefon /1
                                                                ' | nl)"
       echo "$arraylist"
       read -p "Bitte Nummer eingeben: " modanswer
       modtype="${allmodtype[$(($modanswer-1))]}"

     fi

     if [ "$OPTARG" == "del" ]; then

      modifytype="del"

     elif [ "$OPTARG" == "mod" ]; then

      modifytype="mod"
      datenabfrage

     elif [ "$OPTARG" == "delmess" ]; then

      adrdecrypt

      shift $(("$OPTIND"-1))
      nachname="$1"
      vorname="$2"

      # MessDef3
      messidlist="$(sed -n '/^BEGIN:BRIAR\|JAMI\|MASTODON\|TOX\|XMPP/,/^END/{=;p}' "${pathofaddress}/address.lst" | sed 's/^\([0-9]*\)$/|\1:/' | tr -d '\n' | sed 's/|/\n/g' | sed '/^$/d')"

      # Art der IDs und die Position (Zeilennummern) in Adressdatendatei wird in Liste geschrieben.
      while read -r checkid; do
       if [ -n "$(echo "$checkid" | grep '^[0-9]*:BEGIN:')" ]; then
        kindofid="$(echo "$checkid" | grep '^[0-9]*:BEGIN:' | cut -f3 -d':')"
       else
        idlinenr="$(echo "$checkid" | cut -f1 -d':')"
        messidlist="$(echo "$messidlist" | sed '/^'"$idlinenr"':/s/\(^[0-9]*:\)/\1'"$kindofid"':/')"
       fi
      done <<<"$messidlist"

      # Liste wird gesäubert und nach Namen gefiltert.
      if [ -n "$vorname" ]; then
       messidlist="$(echo "$messidlist" | sed '/:BEGIN:\|:END:/d' | grep -i ':'"${nachname}"':'"${vorname}"':')"
      elif [ -n "$nachname" ]; then
       messidlist="$(echo "$messidlist" | sed '/:BEGIN:\|:END:/d' | grep -i ':'"${nachname}"':')"
      else
       echo "Es muss mindestens der Nachname angegeben werden. Vorgang wird abgebrochen."
       exit 1
      fi

      # Ausgabe der Liste auf Bildschirm
      echo ""
      echo "$messidlist" | sed 's/[0-9]*://' | nl
      echo ""

      unset zeilennr
      while [ -z "$zeilennr" ]; do
       read -p "Welche MessengerID soll gelöscht werden. Bitte Nummer angeben: " delid
       [ "$delid" -gt 0 ] && zeilennr="$(echo "$messidlist" | sed -n ''"$delid"'p' | grep -o '^[0-9]*')"
      done

      # Löschung der MessengerID-Zeile aus Adressdatendatei
      echo "Zeile ${zeilennr} wird aus Adressdatendatei gelöscht ..."
      sed -i "${zeilennr}d" "${pathofaddress}/address.lst"

      adrencrypt

      exit 0

     else

      usage
      echo "Ungültige Option!"
      exit 1

     fi

     shift $(("$OPTIND"-1))
     break
  ;;
 
  n) newdata="yes"

     # HTTPS-Servercheck für bestimmte MessengerIDs (z.B. Mastodon)
     wscheck() {
       while true; do
        curl -L --silent --head --max-time 30 --connect-timeout 0 "https://${servercheck}"
        seccheckexit="$?"
        if [ "$seccheckexit" == 0 ]; then
         httpscheck="yes"
         break
        else
         echo "HTTPS-Servercheck war nicht erfolgreich (curl Exitcode: ${seccheckexit})."
         read -p "Vorgang [w]iederholen oder [f]ortfahren, ohne das das Schema in Adressdatei eingetragen wird? " wscheckabfrage
         case "$wscheckabfrage" in
          w|W) continue
          ;;
          f|F) echo "Schema wird nicht in Adressdatei eingetragen."
               httpscheck="no"
              break
          ;;
          *) echo "Fehlerhafte Eingabe!"
          ;;
         esac
        fi
       done
     }

     if [ "$OPTARG" == "vcf" ]; then
     
      # Eingabe eines neuen .vcf-Datensatzes
      datenabfrage
         
      # Bei leeren Einträgen wird das Gerüst aus .vcf-Datei gelöscht.
      vcfcard="$(vcfvorlage)"
      test -z "$fill_birthday" && vcfcard="$(echo "$vcfcard" | sed '/^BDAY:/d')"
      test -z "$fill_tel_home" && vcfcard="$(echo "$vcfcard" | sed '/^TEL;TYPE=home,voice;/d')"
      test -z "$fill_mob_home" && vcfcard="$(echo "$vcfcard" | sed '/^TEL;TYPE=home,cell;/d')"
      test -z "$fill_strasse_home" -a -z "$fill_plz_home" -a -z "$fill_ort_home" -a -z "$fill_land_home"  && vcfcard="$(echo "$vcfcard" | sed '/^ADR;TYPE=home;/d')"
      test -z "$fill_lat_home" -o -z "$fill_lon_home" && vcfcard="$(echo "$vcfcard" | sed '/^GEO;TYPE=home/d')"
      test -z "$fill_url_home" && vcfcard="$(echo "$vcfcard" | sed '/^URL;TYPE=home/d')"
      test -z "$fill_email_home1" && vcfcard="$(echo "$vcfcard" | sed '/^EMAIL;PREF=1;TYPE=home:/d')"
      test -z "$fill_email_home2" && vcfcard="$(echo "$vcfcard" | sed '/^EMAIL;TYPE=home:/d')"
      test -z "$fill_firma" -a -z "$fill_abteilung" -a -z "$fill_beruf" && vcfcard="$(echo "$vcfcard" | sed '/^ORG:/d')"
      test -z "$fill_tel_work" && vcfcard="$(echo "$vcfcard" | sed '/^TEL;TYPE=work,voice;/d')"
      test -z "$fill_mob_work" && vcfcard="$(echo "$vcfcard" | sed '/^TEL;TYPE=work,cell;/d')"
      test -z "$fill_strasse_work" -a -z "$fill_plz_work" -a -z "$fill_ort_work" -a -z "$fill_land_work"  && vcfcard="$(echo "$vcfcard" | sed '/^ADR;TYPE=work;/d')"
      test -z "$fill_lat_work" -o -z "$fill_lon_work" && vcfcard="$(echo "$vcfcard" | sed '/^GEO;TYPE=work/d')"
      test -z "$fill_url_work" && vcfcard="$(echo "$vcfcard" | sed '/^URL;TYPE=work/d')"
      test -z "$fill_email_work1" && vcfcard="$(echo "$vcfcard" | sed '/^EMAIL;PREF=1;TYPE=work:/d')"
      test -z "$fill_email_work2" && vcfcard="$(echo "$vcfcard" | sed '/^EMAIL;TYPE=work:/d')"
      test -z "$fill_note" && vcfcard="$(echo "$vcfcard" | sed '/^NOTE:/d')"
      test -z "$fill_lang" && vcfcard="$(echo "$vcfcard" | sed '/^LANG:/d')"
      # Unnütze Zeilenumbrüche (Label, Note etc.) werden entfernt.
      vcfcard="$(echo "$vcfcard" | sed 's/"\\n/"/g;s/\\n"/"/g;s/\\n *"/"/g')"
      # Zum debuggen
      #echo "$vcfcard" && exit

     # MessDef4
     elif [ "$OPTARG" == "briar" ]; then

      while [ -z "$briarnachname" ]; do
       read -p "Bitte Nachnamen eingeben: " briarnachname
      done
      while [ -z "$briarvorname" ]; do
       read -p "Bitte Vornamen eingeben: " briarvorname
      done
      read -p "Bitte Account-Namen (frei wählbar aber keine : oder ;) eingeben: " briaraccountname
      while [ -n "$(echo "$briaraccountname" | egrep -o '[:;]*')" ]; do
       read -p "Bitte Account-Namen (frei wählbar aber keine : oder ;) eingeben: " briaraccountname
      done
      while [ -z "$briaridwithouts" ]; do
       read -p "Bitte BriarID eingeben (ohne Präfix briar://): " briaridwithouts
      done

     elif [ "$OPTARG" == "jabber" ]; then

      while [ -z "$jidnachname" ]; do
       read -p "Bitte Nachnamen eingeben: " jidnachname
      done
      while [ -z "$jidvorname" ]; do
       read -p "Bitte Vornamen eingeben: " jidvorname
      done
      while [ -z "$jiduser" ]; do
       read -p "Bitte User der JabberID eingeben (ohne Präfix xmpp:): " jiduser
      done
      while [ -z "$jidserver" ]; do
       read -p "Bitte XMPP-Server eingeben: " jidserver
      done

     elif [ "$OPTARG" == "jami" ]; then

      while [ -z "$jaminachname" ]; do
       read -p "Bitte Nachnamen eingeben: " jaminachname
      done
      while [ -z "$jamivorname" ]; do
       read -p "Bitte Vornamen eingeben: " jamivorname
      done
      read -p "Bitte Account-Namen (frei wählbar aber keine : oder ;) eingeben: " jamiaccountname
      while [ -n "$(echo "$jamiaccountname" | egrep -o '[:;]*')" ]; do
       read -p "Bitte Account-Namen (frei wählbar aber keine : oder ;) eingeben: " jamiaccountname
      done
      read -p "Bitte JamiID eingeben (40 Zeichen): " newjamiid

      while [ ! "$(printf "$newjamiid" | wc -m)" == "40" ]; do
       echo "JamiID ist keine 40 Zeichen lang."
       read -p "Bitte JamiID erneut eingeben (40 Zeichen): " newjamiid
      done

     elif [ "$OPTARG" == "mastodon" ]; then

      while [ -z "$mastonachname" ]; do
       read -p "Bitte Nachnamen eingeben: " mastonachname
      done
      while [ -z "$mastovorname" ]; do
       read -p "Bitte Vornamen eingeben: " mastovorname
      done
      while [ -z "$mastouser" ] || [[ "$mastouser" =~ ^@ || "$mastouser" =~ @$ ]]; do
       read -p "Bitte Mastodon-User eingeben (ohne Präfix @): " mastouser
      done
      while [ -z "$mastoserver" ] || [[ "$mastoserver" =~ ^@ || "$mastoserver" =~ @$ || "$mastoserver" =~ ^http ]]; do
       read -p "Bitte Mastodon-Server eingeben (ohne Präfix @ oder http(s): " mastoserver
      done
      # Servercheck
      servercheck="$mastoserver"
      wscheck

     elif [ "$OPTARG" == "tox" ]; then

      while [ -z "$toxnachname" ]; do
       read -p "Bitte Nachnamen eingeben: " toxnachname
      done
      while [ -z "$toxvorname" ]; do
       read -p "Bitte Vornamen eingeben: " toxvorname
      done
      read -p "Bitte Account-Namen (frei wählbar aber keine : oder ;) eingeben: " toxaccountname
      while [ -n "$(echo "$toxaccountname" | egrep -o '[:;]*')" ]; do
       read -p "Bitte Account-Namen (frei wählbar aber keine : oder ;) eingeben: " toxaccountname
      done
      read -p "Bitte ToxID eingeben (76 Zeichen): " newtoxid

      while [ ! "$(printf "$newtoxid" | wc -m)" == "76" ]; do
       echo "ToxID ist keine 76 Zeichen lang."
       read -p "Bitte ToxID erneut eingeben (76 Zeichen): " newtoxid
      done
     
     else
      
      usage
      echo -e "Ungültiges Argument.\n"
      exit 1
      
     fi
     
     adrdecrypt
     
     if [ "$OPTARG" == "vcf" ]; then
     
      seiteteil1="$(sed -n '1,/^END:VCF/p' "${pathofaddress}/address.lst" | sed '$d')"
      seiteteil2="$(sed -n '/^END:VCF/,$p' "${pathofaddress}/address.lst")"
      echo "$seiteteil1" >"${pathofaddress}/address.lst"
      echo "$vcfcard" >>"${pathofaddress}/address.lst"
      echo "$seiteteil2" >>"${pathofaddress}/address.lst"

     # MessDef5
     elif [ "$OPTARG" == "briar" ]; then

      briarnewline="$(echo "${briarnachname}:${briarvorname}:${briaraccountname}:${briaridwithouts}")"
      sed -i 's/\(END:BRIAR\)/'"$briarnewline"'\n\1/' "${pathofaddress}/address.lst"

     elif [ "$OPTARG" == "jabber" ]; then

      jidnewline="$(echo "${jidnachname}:${jidvorname}:${jiduser}:${jidserver}")"
      sed -i 's/\(END:XMPP\)/'"$jidnewline"'\n\1/' "${pathofaddress}/address.lst"

     elif [ "$OPTARG" == "jami" ]; then

      jaminewline="$(echo "${jaminachname}:${jamivorname}:${jamiaccountname}:${newjamiid}")"
      sed -i 's/\(END:JAMI\)/'"$jaminewline"'\n\1/' "${pathofaddress}/address.lst"

    elif [ "$OPTARG" == "mastodon" ]; then

      mastonewline="$(echo "${mastonachname}:${mastovorname}:${mastouser}:${mastoserver}:${httpscheck}")"
      sed -i 's/\(END:MASTODON\)/'"$mastonewline"'\n\1/' "${pathofaddress}/address.lst"

     elif [ "$OPTARG" == "tox" ]; then

      toxnewline="$(echo "${toxnachname}:${toxvorname}:${toxaccountname}:${newtoxid}")"
      sed -i 's/\(END:TOX\)/'"$toxnewline"'\n\1/' "${pathofaddress}/address.lst"
     
     fi
     
     adrencrypt
     
     exit
  ;;

  r) gcalcheck
     datefilecheck

     # ***** Terminerinnerung - Anfang *****
     # Greift nur, wenn Variable remind in .conf-Datei auf "yes" gesetzt wurde.
     if [ "$remind" == "yes" ]; then

        [ -z "$(type -p at)" ] && logger -s --id=$$ "Das Programm at ist nicht installiert. Skript wird abgebrochen!" && exit 1

        gcalcontent="$(gcal --exclude-fixed-dates-list-title --highlighting=no -f "$datefile" -c | sed '/^$/d')"
        # Uhrzeiten werden zuerst alle in Minuten umgerechnet, dann verglichen und wieder umgerechnet.
        zeitjetzt="$(date '+%H%M')"
        zeitjetztmin="$(echo ${zeitjetzt#??} | sed 's/^0//')"
        zeitjetztstd="$(echo ${zeitjetzt%??} | sed 's/^0//')"
        zeitjetztinmin=$((${zeitjetztstd} * 60 + ${zeitjetztmin}))

        # ** Logdatei ggf. anlegen **
        # Die Logdatei ist deshalb notwendig, weil ggf. nach erneutem Aufruf der Option -r die Termine unter Umständen bereits in der
        # at-Jobliste vorhanden sind.
        # Gleiche Termine bleiben unverändert.
        # Termine, wo noch eine Terminerinnerung verschickt werden soll, aber der Inhalt geändert wurde, werden wie folgt behandelt:
        # Veraltete (geänderte) Termine werden gelöscht (at-Jobliste und .at.log-Datei)
        # Neue Termine werden der at-Jobliste zugeführt.
        # Zeitlich abgelaufene (ausgeführte) Jobs bleiben bis zur nächsten Änderung in der .at.log-Datei.
        [ "$OPTARG" == mail ] && atlogfile="${pathofaddress}/.at_mail.log"
        [ "$OPTARG" == notify ] && atlogfile="${pathofaddress}/.at_notify.log"
        [ "$(date '+%Y%m%d')" != "$(cat "$atlogfile" 2>/dev/null | sed -n '1p')" -o ! -e "$atlogfile" ] && date '+%Y%m%d' >"$atlogfile"

        while read -r dline; do

         unset startzeitraw
         unset startzeitinmin
         unset makeatjob

         # Prüfsumme für at-JobID-Vergleich
         dlinehash="$(echo -n "$dline" | md5sum | sed 's/ *-$//')"
         hashlist+="$dlinehash"$'\n'

         # Es wird nur die früheste Uhrzeit im Format HH:MM ausgewertet.
         uhrzeit="$(echo "$dline" | egrep -o '[0-9]{2}:[0-9]{2}' | sort -n)"
         anzzeiten="$(echo "$uhrzeit" | sed '/^$/d' | wc -l)"

         if [ "$anzzeiten" -gt 0 ]; then
          startzeitraw="$(echo "$uhrzeit" | sed -n '1p' | sed 's/://')"

          # ** Uhrzeit des Termins analysieren - Anfang **
          if [ "$startzeitraw" -gt 2400 ]; then
           logger -s --id=$$ "Terminerinnerung: Ungültiges Uhrzeitformat: ${dline}"
           exit 1
          else
           # Die evtl. führende Null in startzeit*raw muss entfernt werden, da es sonst zu Fehlermeldung kommt.
           # Siehe auch oben bei zeitjetzt*
           startzeitminraw="$(echo ${startzeitraw#??} | sed 's/^0//')"
           startzeitstdraw="$(echo ${startzeitraw%??} | sed 's/^0//')"
           startzeitinminraw=$((${startzeitstdraw} * 60 + ${startzeitminraw}))

           # Überprüfung der Variable minutesbefore
           if [ -n "$minutesbefore" -a ! $(echo "$minutesbefore" | grep -E '^[[:digit:]]+$') ]; then
            logger -s --id=$$ "Ungültiges Format in config-Datei in Variable minutesbefore (${minutesbefore})"
            exit 1
           elif [ -z "$minutesbefore" ]; then
            minutesbefore=0
           else
            # Mögliche zu Beginn angegebene Nullen werden entfernt (Siehe dazu auch oben).
            [ ! "$minutesbefore" == "0" ] && minutesbefore="$(echo ${minutesbefore} | sed 's/^0//')"
           fi

           startzeitinmin=$((${startzeitinminraw} - ${minutesbefore}))
          fi
          # ** Uhrzeit des Termins analysieren - Ende **

          # ** Auswertung und Ausgabe der Terminerinnerung - Anfang **
          # Es werden nur Termine an at übergeben, die außerhalb von minutesbefore in der Zukunft liegen.
          # Andere Termine des aktuellen Tages werden ja sowieso publiziert (siehe unten).
          if [ -n "$(echo "$startzeitinmin" | grep '^-')" ]; then

           echo "Hinweis: Startzeit der Terminerinnerung liegt im Bereich des gestrigen Tages."

          else

           # Uhrzeit des Termins wird wieder in das ursprüngliche Format umgerechnet.
           startzeit="$(printf '%02d:%02d\n' $(($startzeitinmin%3600/60)) $(($startzeitinmin%60)))"
           zeitdiff=$((${startzeitinminraw} - ${zeitjetztinmin}))
           if [ "$startzeitinminraw" -le "$zeitjetztinmin" -a "$zeitdiff" -le "$minutesbefore" ]; then
            echo "Hinweis: Vergangener Termin des heutigen Tages ($(echo "$uhrzeit" | sed -n '1p') Uhr) gefunden."
           elif [ "$zeitdiff" -le "$minutesbefore" ]; then
            echo "Hinweis: Termin ($(echo "$uhrzeit" | sed -n '1p') Uhr) innerhalb der nächsten ${minutesbefore} Minuten gefunden."
           else

            # at-Jobs checken
            dlinehashcheck="$(cat "$atlogfile" | grep "$dlinehash")"
            if [ -n "$dlinehashcheck" ]; then
             atjobidlog="$(echo "$dlinehashcheck" | sed 's/^job \([0-9]*\) .*$/\1/')"
             atqjobid="$(atq | grep '^'"$atjobidlog"'[[:space:]]' | grep -o '^[0-9]*')"
             if [ "$atjobidlog" == "$atqjobid" ]; then
              echo "Termin (JobID: ${atjobidlog}/$(echo "$uhrzeit" | sed -n '1p') Uhr) ist schon in at-Jobliste."
             elif [ "$atjobidlog" != "$atqjobid" ]; then
              echo "Unterschiedliche JobIDS bei gleichem Termin gefunden. Bitte prüfen! Es wird kein neuer at-Job erstellt."
              echo "Hashwert              : ${dlinehash}"
              echo "JobID in Logdatei     : ${atjobidlog}"
              echo "JobID von atq-Ausgabe : ${atqjobid}"
             fi
            else
             echo "Termin ($(echo "$uhrzeit" | sed -n '1p') Uhr) wird an at übergeben."
             makeatjob="yes"
            fi

            if [ "$OPTARG" == mail ]; then

             if [ -n "$keyfingerprint" ]; then

              if [ -z "$(type -p gpg)" ]; then
               logger -s --id=$$ "Programm gnupg2 ist nicht installiert. Bitte erst installieren. Skript wird abgebrochen."
               exit 1
              fi
              if [ "$(gpg --fingerprint "$keyfingerprint" &>/dev/null; echo $?)" != 0 ]; then
               logger -s --id=$$ "Kein gültigen öffentlichen GPG-Schlüssel gefunden. Skript wird abgebrochen."
               exit 1
              else

               if [ "$makeatjob" == "yes" ]; then
                echo "echo \"${dline}\" | gpg --encrypt -a --recipient \"$keyfingerprint\" | mail -a \"Content-Type: text/plain; charset=UTF-8\" -s \"$mailsubject2\" \"$mailaddr\"" | at ${startzeit} &>>"$atlogfile"
                sed -i '$s/\(.*$\)/\1#'"$dlinehash"'#mail/' "$atlogfile"
               fi

              fi

             else

              if [ "$makeatjob" == "yes" ]; then
               echo "echo \"${dline}\" | mail -a \"Content-Type: text/plain; charset=UTF-8\" -s \"$mailsubject2\" \"$mailaddr\"" | at ${startzeit} &>>"$atlogfile"
               sed -i '$s/\(.*$\)/\1#'"$dlinehash"'#mail/' "$atlogfile"
              fi

             fi

            elif [ "$OPTARG" == notify ]; then

              [ -z "$(type -p notify-send)" ] && logger -s --id=$$ "Das Programm notify-send aus dem Paket libnotify-bin ist nicht installiert. Skript wird abgebrochen!" && exit 1
              if [ "$makeatjob" == "yes" ]; then
               echo "notify-send -i /usr/share/icons/gnome/48x48/status/info.png \"$notifysubject2\" \"$dline\"" | at ${startzeit} &>>"$atlogfile"
               sed -i '$s/\(.*$\)/\1#'"$dlinehash"'#notify/' "$atlogfile"
              fi
            fi

           fi

          fi
          # ** Auswertung und Ausgabe der Terminerinnerung - Ende **

         fi

        done <<<"$gcalcontent"

        # *** Löschen der veralteten Jobs aus at-Jobliste und aus Logdatei (zeitlich abgelaufene Einträge bleiben in der Datei!) ***
        # Veraltete Jobs sind zum Beispiel Termine, wo sich der Inhalt geändert hat aber die Zeit noch in der Zukunft liegt.

        # Logdatei bereinigen und unnütze Zeilen löschen
        sed -i '/^warning: commands will be executed using/d' "$atlogfile"
        hashlist="$(echo "$hashlist" | sed '/^$/d' | sort)"
        hashlistlogfile="$(cat "$atlogfile" | grep '^job' | cut -f2 -d'#' | sort)"

        altejobs="$(diff <(echo "$hashlist") <(echo "$hashlistlogfile") | grep '^>' | cut -f2 -d' ')"

        if [ -n "$altejobs" ]; then

         # JobIDs der alten Jobs werden ermittelt.
         while read -r oldjob; do
          jobline="$(cat "$atlogfile" | grep "$oldjob")"
          oldjobid="$(echo "$jobline" | sed 's/^job \([0-9]*\) .*$/\1/')"
          oldjobidlist+="${oldjobid} "
         done <<<"$altejobs"

         # Löschen der alten JobIDs aus at-Jobliste und .at.log (Wichtig!)
         echo "Alte(r) Job(s) (${oldjobidlist% }) wird/werden gelöscht."
         deljobs=(${oldjobidlist% })
         for djob in ${deljobs[@]}; do
          # Man könnte auch z.B. atrm ID ID ID eingeben. Da sich aber unter Umständen auch noch alte, abgelaufene Einträge
          # in .at.log befinden können, wird dies einzeln in dieser Schleife gemacht.
          [ -n "$(atq "${djob}")" ] && atrm "$djob"
          sed -i '/^job '$djob' /d' "$atlogfile"
         done

        fi

     fi
     # ***** Terminerinnerung - Ende *****

     # Dies ist wichtig, wenn man die Terminerinnerung mit Cron überwachen möchte.
     # Termine des Tages werden dann nicht mit ausgegeben.
     shift $(($OPTIND - 1))
     [ "$1" == "remindupdate" ] && exit

     # Einige gcal Optionen:
     #--heading-text="Deine Termine heute:" (Personalisierte Überschrift)
     #--exclude-fixed-dates-list-title (Überschrift unterdrücken)
     if [ "$OPTARG" == mail ]; then

      [ -z "$(type -p mail)" ] && logger -s --id=$$ "Das Programm mail ist nicht installiert. Skript wird abgebrochen!" && exit 1

      gcalcontent="$(gcal --highlighting=no -f "$datefile" -c)"

      # Wenn keine Termine vorliegen, ist gcalcontent leer und sendet dann nix.
      if [ -n "$gcalcontent" ]; then

       mailcounter=0
       while [ "$mailcounter" -lt 5 -a "$mailexit" != 0 ]; do

         if [ -n "$keyfingerprint" ]; then

           if [ -z "$(type -p gpg)" ]; then
            logger -s --id=$$ "Programm gnupg2 ist nicht installiert. Bitte erst installieren. Skript wird abgebrochen."
           exit 1
           fi
           if [ "$(gpg --fingerprint "$keyfingerprint" &>/dev/null; echo $?)" != 0 ]; then
            logger -s --id=$$ "Kein gültigen öffentlichen GPG-Schlüssel gefunden. Skript wird abgebrochen."
            exit 1
           fi
           echo "$gcalcontent" | gpg --encrypt -a --recipient "$keyfingerprint" | mail -a "Content-Type: text/plain; charset=UTF-8" -s "$mailsubject" "$mailaddr"
           mailexit="$?"

         else

           echo "$gcalcontent" | mail -a "Content-Type: text/plain; charset=UTF-8" -s "$mailsubject" "$mailaddr"
           mailexit="$?"

         fi

         let mailcounter++

         if [ "$mailexit" == 0 ]; then
          echo "${0}: E-mail zugestellt am `date +%d.%m.%Y` um `date +%H:%M` Uhr." | tee >(logger --id=$$)
          break
         fi
         sleep 30

       done
       [ "$mailcounter" -ge 5 ] && logger -s --id=$$ "Zustellen der Mail wurde nach 5 Versuchen abgebrochen."
       [ "$mailexit" != 0 ] && logger -s --id=$$ "Fehler von mail (Exitstatus: ${mailexit})"

      fi

     elif [ "$OPTARG" == notify ]; then

      gcalcontent="$(gcal --exclude-fixed-dates-list-title --highlighting=no -f "$datefile" -c)"
      [ -z "$(type -p notify-send)" ] && logger -s --id=$$ "Das Programm notify-send aus dem Paket libnotify-bin ist nicht installiert. Skript wird abgebrochen!" && exit 1
      [ -n "$gcalcontent" ] && notify-send -i /usr/share/icons/gnome/48x48/status/info.png "$notifysubject" "$gcalcontent"

     else

      echo "${OPTARG} ist nicht definiert."

     fi
     exit
  ;;

  s) datefilecheck
     filesync

     # Das shiften ist wichtig, damit ggf.die Namen für die Adressausgabe später korrekt ausgewertet werden.
     # Damit kann Option -s mit anderen Möglichkeiten kombiniert werden.
     shift $(($OPTIND - 1))
     # Wenn keine weiteren Argumente nach Option -s definiert sind, wird Skript beendet.
     [ -z "$*" ] && exit
  ;;

  u) kuerzel="${OPTARG,,}"
     if [ "$kuerzel" == "at" ]; then
      countrylist=(at)
     elif [ "$kuerzel" == "ch" ]; then
      countrylist=(ch)
     elif [ "$kuerzel" == "de" ]; then
      countrylist=(de)
     elif [ "$kuerzel" == "all" ]; then
      countrylist=(at ch de)
     else
      echo "Ungültige Angabe (${kuerzel}). Skript wird abgebrochen."
      exit 1
     fi
     holiupdate
     # Das shiften ist wichtig, damit ggf.die Namen für die Adressausgabe später korrekt ausgewertet werden.
     # Damit kann Option -s mit anderen Möglichkeiten kombiniert werden.
     shift $(($OPTIND - 1))
     # Wenn keine weiteren Argumente nach Option -s definiert sind, wird Skript beendet.
     [ -z "$*" ] && exit
  ;;

  w) gcalcheck
     datefilecheck
     if [ "$modifysync" == "yes" ]; then
      filesync
      [ "$syncerr" == 1 ] && read -p "Ohne Synchronisation weiter mit [ENTER]. Abbruch mit [STRG]+[C]"
     fi
     nano "$datefile"
     [ "$modifysync" == "yes" ] && filesync
     exit
  ;;

  W) # Änderung der Adressdatei manuell vornehmen.
  
     adrdecrypt
     
     nano "${pathofaddress}/address.lst"
     
     adrencrypt
     exit
  ;;

  ?) exit 1
  ;;
  
 esac
done

# ***** Kalenderoptionen *****
if [ "$optccal" == "yes" -o "$optdcal" == "yes" -o "$optfcal" == "yes" ]; then

 ejahr="${!#}"
 [[ ! "$ejahr" =~ ^[0-9][0-9][0-9][0-9]$ ]] && ejahr="$(date '+%Y')"

 # *** Option -C - Anfang ***
 if [ "$optccal" == "yes" -a ! "$onlychelp" == "yes" ]; then

  calprint="yes"
  if [ "$dateformat" == "DE" ]; then
   dateformatcheck="yes"
  else
   echo "Keine gültige Länderkennung in config-Datei definiert."
   exit 1
  fi

  ccontent() {
   for cc in ${countrycodes[@]}; do
    echo "$cc"
   done | nl
  }

  exdays() {
   if [ -n "$excludedays" ]; then
    for excd in "${excludedays[@]}"; do
     callinenr+="$(echo "$calcontent" | grep -ni "$excd" | grep -o "^[0-9]*"),"
     calcontent="$(echo "$calcontent" | sed "/${excd}/d")"
    done
   fi
  }

  hlight() {
   # Beschreibung der einzelnen sed-Befehle:
   # 1. Im oberen Kalenderbereich werden aufeinanderfolgende, (gesetzliche) Feiertage eingefärbt (Zahlen: (einstellig) - zweistellig).
   # 2. Im oberen Kalenderbereich wird das aktuelle Datum eingefärbt.
   # 3. Im unteren Kalenderbereich werden die Zeilen mit den (gesetzlichen) Feiertagen eingefärbt.
   # 4. Im unteren Kalenderbereich werden die Zeilen mit besonderen Feiertagen eingefärbt, die nicht gesetzlich sind.
   # 5. Aufräumen, wenn im oberen Kalenderbereich mehrere (gesetzliche) Feiertage horizontal nebeneinander liegen (siehe Punkt 1 und 2).
   [ "$highlighting" == "yes" ] && calcontent="$(echo "$calcontent" | sed '
                                                / [+#] /!s/:\( *\)\([0-9:]*\):/ \\e\[0;31;1m\1\2\\e\[0m /g
                                                / [+#] /!s/<\( *[0-9]*\)>/ \\e\[30;47m\1\\e\[0m /
                                                / + /s/\(^.*\):\( *[0-9]*\):\(.*$\)/\\e\[0;31;1m\1 \2 \3\\e\[0m/
                                                / # /s/\(^.*\):\( *[0-9]*\):\(.*$\)/\\e\[0;31m\1 \2 \3\\e\[0m/
                                                s/\([0-9]\):/\1 /g
                                               ')"
  }


  if [ "$causwahl" == "?" ]; then
   while [ -z "$auswahl" ]; do
    ccontent
    read -p "Bitte Ländercode auswählen: " land
    auswahl="$(ccontent | grep "[[:space:]]${land}[[:space:]]" | sed 's/^ *//' | cut -f2)"
   done
  else
   auswahl="$causwahl"
  fi

  if [ -n "$extholidays" ]; then

   # Doppelte Tage werden rausgefiltert.
   daylist="$(gcal --date-format="$dateformat" -q${auswahl} --holiday-list --"$extholidays"  $(date +%Y) 2>/dev/null | grep -o '[+-][0-9]* [[:alnum:]]*$' | uniq -d)"
   if [ "$highlighting" == "yes" ]; then
    calcontent="$(gcal --date-format="$dateformat" -K -q${auswahl} --holiday-list --"$extholidays" "$ejahr")"
    hlight
   else
    calcontent="$(gcal --date-format="$dateformat" -H no -K -q${auswahl} --holiday-list --"$extholidays" "$ejahr")"
   fi

   # Doppelte Tage mit Inhalt der Variable extholidaysabbr werden gelöscht.
   extholidaysabbr="$(gcal --date-format="$dateformat" --holiday-list --"$extholidays" | grep -o '(.*)' | uniq | sed 's/[()]//g')"
   [ -n "$extholidaysabbr" ] && while read -r oneday; do
                                 calcontent="$(echo "$calcontent" | sed '
                                               /('"$extholidaysabbr"').*'"$oneday"'/d
                                             ')"
                                done <<<"$daylist"

   exdays
   [ -n "$calcontent" ] && echo -e "$calcontent"

  else

   if [ "$highlighting" == "yes" ]; then
    calcontent="$(gcal --date-format="$dateformat" -K -q${auswahl} --holiday-list $(date +%Y))"
    hlight
   else
    calcontent="$(gcal --date-format="$dateformat" -H no -K -q${auswahl} --holiday-list $(date +%Y))"
   fi

   exdays
   [ -n "$calcontent" ] && echo -e "$calcontent"

  fi
  echo ""

 fi
 # *** Option -C - Ende ***

 # *** Option -D - Anfang ***
 if [ "$optdcal" == "yes" ]; then

  if [ "$calprint" == "yes" ]; then
   gcal -u -f "$datefile" "$ejahr"
  else
   calprint="yes"
   gcal -K -f "$datefile" "$ejahr"
  fi
  echo ""

 fi
 # *** Option -D - Ende ***

 # *** Option -F - Anfang ***
 if [ "$optfcal" == "yes" ]; then

  prntsource() {
   echo ""
   echo "Schulferiendaten:"
   [ -n "$holilist" ] && cat "${pathofaddress}/holidays/${fkuerzelc}/timestamp.log"
   cat "${pathofaddress}/holidays/SOURCE"
  }

  holilist="$(grep ';'"${ejahr}"'-' "$fpath" 2>/dev/null)"
  if [ -n "$holilist" ]; then
   if [ "$calprint" == "yes" ]; then
     gcal -u "$ejahr"
    else
     calprint="yes"
     gcal -K "$ejahr"
     echo ""
    fi
    if [ -n "$fkuerzels" ]; then
     subname=" ($(grep ';'"${fkuerzelc^^}-${fkuerzels^^}"';' "${pathofaddress}/holidays/${fkuerzelc}/subdivisions.csv" | cut -f6 -d';' | sed 's/.*DE \([^,]*\),\{,1\}.*/\1/'))"
    fi
    echo "Schulferien für $(grep "^${fkuerzelc^^}" "${pathofaddress}/holidays/countries.csv" | cut -f2 -d';' | sed 's/.*DE \([^,]*\),\{,1\}.*/\1/')${subname}:"
    printf '\n%-12s %-10s %-30s\n\n' "$(echo "Beginn")" "$(echo "Ende")" "$(echo "Bezeichnung")"

    unset allsub
    while read -r holiline; do
     hstart="$(cut -f3 -d';' <<<"$holiline")"
     hend="$(cut -f4 -d';' <<<"$holiline")"
     [ -n "$hend" ] && hverb="-" || hverb=""
     hbez="$(cut -f6 -d';' <<<"$holiline")"
     hsub="$(cut -f7 -d';' <<<"$holiline")"
     if [ ! "${hsub,,}" == "$fkuerzels" ]; then
      prntsub="$hsub"
      allsub+="${hsub},"
     else
      prntsub=""
     fi
     hcom="$(cut -f8 -d';' <<<"$holiline" | sed 's/.*DE \([^,]*\),\{,1\}.*/\1/')"
     [ -n "$hcom" ] && prntcom="$hcom" || prntcom=""
     printf '%10s %1s %10s %-25s %-16s %-25s\n' "$(sed 's/^\(.*\)-\(.*\)-\(.*\)$/\3.\2.\1/' <<<"$hstart")" "$hverb" "$(sed 's/^\(.*\)-\(.*\)-\(.*\)$/\3.\2.\1/' <<<"$hend")" "$(sed 's/.*DE \([^,]*\),\{,1\}.*/\1/' <<<"$hbez")" "$prntsub" "$prntcom" | sed 's/[[:space:]]\{20\}//g'
    done <<<"$holilist"

    # Hinweise zu Abkürzungen
    if [ -n "$allsub" ]; then
     echo -e "\nHinweise:"
     abbrlist="$(echo "$allsub" | tr ',' '\n' | sort | uniq | sed '/^$/d')"
     while read -r hinweis; do
      grep ';'"${hinweis}"';' "${pathofaddress}/holidays/${fkuerzelc}/subdivisions.csv"  | cut -f6 -d';' | sed 's/.*DE \([^,]*\),\{,1\}.*/'"$hinweis"' = \1/'
     done <<<"$abbrlist"
    fi

    prntsource

  elif [ "$onlyfhelp" == "yes" ]; then

   echo -e "\nMögliche Länderkürzel für Ferientermine:"
   hdirlist=($(find "${pathofaddress}/holidays" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;))
   for land in "${hdirlist[@]}"; do

    lline="$(grep "^${land^^}" "${pathofaddress}/holidays/countries.csv" 2>/dev/null)"
    lsublines="$(grep "^${land^^}" "${pathofaddress}/holidays/${land}/subdivisions.csv" 2>/dev/null | cut -f 1,4,6 -d';' | egrep '^[A-Z]{2};[A-Z]{2};')"
    if [ -n "$lline" -a -n "$lsublines" ]; then
     llongname="$(echo "$lline" | cut -f2 -d';' | sed 's/.*DE \([^,]*\),\{,1\}.*/\1/')"
     echo -e "\n${llongname}:"
     if [ "$land" == "at" ]; then
      echo "${land^^}"
     else
      lkue="$(echo "$lsublines" | cut -f1,2 -d';' | sed 's/;/_/')"
      lname="$(echo "$lsublines" | cut -f3 -d';' | sed 's/.*DE \([^,]*\),\{,1\}.*/\1/')"
      paste <(echo "$lkue") <(echo "$lname") | sed 's/\([A-Z]\{2\}\)[[:space:]]*\([A-Z]\{2\}\)\(.*\)/\1_\2 \3/'
     fi
    else
     echo "Feriendaten (${land^^}) unvollständig. Bitte erst downloaden (Option -u)."
     echo "Skript wird abgebrochen!"
     exit 1
    fi

   done
   prntsource

  else

   echo "Keine Daten vorhanden."

  fi
  echo ""

 fi
 # *** Option -F - Ende ***

 # Programm wird nach den Kalenderoptionen beendet.
 exit

fi
# ***** Kalenderoptionen - Ende *****

if [ -z "$1" ]; then
 usage
 echo -e "\nBitte mindestens einen Nachnamen angeben. Skript wird abgebrochen."
 exit 1
fi

# Der komplette Content aus der Adressenliste wird in folgende Variable geschrieben.
if [ "$modifymodus" == "yes" ]; then
 adrdecrypt
 adrlistcontent="$(cat ${pathofaddress}/address.lst)"
 # Hier wird parallel zu adrlistcontent eine weitere Variable mit gleichem Inhalt,
 # aber mit Zeilennummern definiert.
 # Mit folgender Variable wird später die Zeile identifiziert, die geändert werden soll.
 adrlistcontentnr="$(echo "$adrlistcontent" | nl -ba -nln)"
else
 echo "Adressdaten werden aus der verschlüsselten Datei abgerufen."
 adrlistcontent="$(ccat ${pathofaddress}/address.lst.cpt)"
fi
if [ -z "$adrlistcontent" ]; then
 exit 1
fi

# Variablen definieren
nachname="$1"
vorname="$2"

vcfcontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:VCARD/,/END:VCARD/p')"
if [ "$modifymodus" == "yes" ]; then
 vcfcontentnr="$(echo "$adrlistcontentnr" | sed -n '/BEGIN:VCARD/,/END:VCARD/p')"
fi
anzvcfcontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:VCARD/p' | wc -l)"
 
vcardcheck="0"
messcounter="0"
for vcardbeg in $(seq 1 "$anzvcfcontent"); do
 
  vcfsinglecontent="$(echo "$vcfcontent" | sed -n '1,/END:VCARD/p')"
  if [ "$modifymodus" == "yes" -a "$vcardcheck" == "0" ]; then
   vcfsinglecontentnr="$(echo "$vcfcontentnr" | sed -n '1,/END:VCARD/p')"
  fi

  # Der ggf. ermittelte Vorname wird über die vcard ermittelt.
  # Es muss nämlich in der Adressenliste immer eine vcard angelegt werden, auch wenn z.B. nur eine Briar-Adresse vorhanden ist.
  # Achtung: Ansonsten werden Messenger-Adressen (Briar, etc.) nicht mit ausgewertet!
  #          Außerdem sollten alle grep-Befehle mit -i ausgeführt werden (ignoriert Groß/Kleinschreibung):
  if [ "$1" == "*" ]; then
   vcfsinglecontentline="$(echo "$vcfsinglecontent" | grep -i '^N:')"
   nachname="$(echo "$vcfsinglecontentline" | sed -n 's/^N://p' | cut -f1 -d';')"
   vorname="$(echo "$vcfsinglecontentline" | sed -n 's/^N://p' | cut -f2 -d';')"
  elif [ -n "$2" ]; then
   vcfsinglecontentline="$(echo "$vcfsinglecontent" | grep -i '^N:'"$nachname"';'"$vorname"';')"
  else
   vcfsinglecontentline="$(echo "$vcfsinglecontent" | grep -i '^N:'"$nachname"';')"
   vorname="$(echo "$vcfsinglecontentline" | sed -n 's/^N://p' | cut -f2 -d';')"
  fi
  
  # Bei Fund mit dem entsprechenden Namen in Vcard wird nach Messenger-Adressen (Briar, etc) gesucht.
  if [ -n "$vcfsinglecontentline" ]; then
  
   let vcardcheck++

   # MessDef6
   # Variablen werden definiert
   briarcontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:BRIAR/,/END:BRIAR/p' | grep -i '^'"$nachname"':'"$vorname"'')"
   jabbercontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:XMPP/,/END:XMPP/p' | grep -i '^'"$nachname"':'"$vorname"'')"
   jamicontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:JAMI/,/END:JAMI/p' | grep -i '^'"$nachname"':'"$vorname"'')"
   mastodoncontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:MASTODON/,/END:MASTODON/p' | grep -i '^'"$nachname"':'"$vorname"'')"
   toxcontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:TOX/,/END:TOX/p' | grep -i '^'"$nachname"':'"$vorname"'')"

   adr_home_singleline="$(echo "$vcfsinglecontent" | grep '^ADR;TYPE=home;')"
   adr_home_strasse="$(echo "$adr_home_singleline" | cut -d';' -f5)"
   adr_home_plz="$(echo "$adr_home_singleline" | cut -d';' -f8)"
   adr_home_ort="$(echo "$adr_home_singleline" | cut -d';' -f6)"
   adr_home_land="$(echo "$adr_home_singleline" | cut -d';' -f9)"
   geo_uri_home="$(echo "$vcfsinglecontent" | sed -n 's/^GEO.*TYPE=home.*\(geo:.*\)/\1/p')"

   adr_work_singleline="$(echo "$vcfsinglecontent" | grep '^ADR;TYPE=work;')"
   adr_work_orgaline="$(echo "$vcfsinglecontent" | sed -n 's/^ORG:\(.*\)/\1/p')"
   adr_work_org="$(echo "$adr_work_orgaline" | cut -d';' -f1)"
   org_work_abt="$(echo "$adr_work_orgaline" | cut -d';' -f2)"
   org_work_beruf="$(echo "$adr_work_orgaline" | cut -d';' -f3)"
   adr_work_strasse="$(echo "$adr_work_singleline" | cut -d';' -f5)"
   adr_work_plz="$(echo "$adr_work_singleline" | cut -d';' -f8)"
   adr_work_ort="$(echo "$adr_work_singleline" | cut -d';' -f6)"
   adr_work_land="$(echo "$adr_work_singleline" | cut -d';' -f9)"
   geo_uri_work="$(echo "$vcfsinglecontent" | sed -n 's/^GEO.*TYPE=work.*\(geo:.*\)/\1/p')"
   
   con_tel_home="$(echo "$vcfsinglecontent" | grep '^TEL;TYPE=home,voice;' | cut -d';' -f3 | sed 's/^.*tel:\(.*\)/\1/')"
   con_mob_home="$(echo "$vcfsinglecontent" | grep '^TEL;TYPE=home,cell;' | cut -d';' -f3 | sed 's/^.*tel:\(.*\)/\1/')"
   con_website_home="$(echo "$vcfsinglecontent" | sed  -n 's/^URL;TYPE=home:\(.*\)/\1/p')"
   anzemail_home="$(echo "$vcfsinglecontent" | grep -c  '^EMAIL.*TYPE=home')"
   if [ "$anzemail_home" == "1" ]; then
    con_email_home="$(echo "$vcfsinglecontent" | sed  -n 's/^EMAIL.*TYPE=home:\(.*\)/\1/p')"
   elif [ "$anzemail_home" -gt "1" ]; then
    con_email_home="$(echo "$vcfsinglecontent" | grep '^EMAIL' | sort -n -t'=' -k2 | sed -n 's/^EMAIL.*TYPE=home:\(.*\)/\1/p' | sed -n -e '1h;1!p;${g;p;}' | sed '2,$s/^/                       /')"
   fi
   
   con_tel_work="$(echo "$vcfsinglecontent" | grep '^TEL;TYPE=work,voice;' | cut -d';' -f3 | sed 's/^.*tel:\(.*\)/\1/')"
   con_mob_work="$(echo "$vcfsinglecontent" | grep '^TEL;TYPE=work,cell;' | cut -d';' -f3 | sed 's/^.*tel:\(.*\)/\1/')"
   con_website_work="$(echo "$vcfsinglecontent" | sed  -n 's/^URL;TYPE=work:\(.*\)/\1/p')"
   anzemail_work="$(echo "$vcfsinglecontent" | grep -c  '^EMAIL.*TYPE=work')"
   if [ "$anzemail_work" == "1" ]; then
    con_email_work="$(echo "$vcfsinglecontent" | sed  -n 's/^EMAIL.*TYPE=work:\(.*\)/\1/p')"
   elif [ "$anzemail_work" -gt "1" ]; then
    con_email_work="$(echo "$vcfsinglecontent" | grep '^EMAIL' | sort -n -t'=' -k2 | sed -n 's/^EMAIL.*TYPE=work:\(.*\)/\1/p' | sed -n -e '1h;1!p;${g;p;}' | sed '2,$s/^/                       /')"
   fi

   muttersprache="$(echo "$vcfsinglecontent" | sed -n 's/^LANG:\(.*$\)/\1/p')"
   sonstiges="$(echo "$vcfsinglecontent" | sed  -n 's/^NOTE:\(.*\)/\1/p')"
   birthday="$(echo "$vcfsinglecontent" | sed  -n 's/^BDAY:\(....\)\(..\)\(..\)/\3.\2.\1/p')"
   dateofvcf="$(echo "$vcfsinglecontent" | sed  -n 's/^REV:\(....\)\(..\)\(..\)T......Z/\3.\2.\1/p')"

   if [ ! "$modifymodus" == "yes" ]; then

    printcounter=0
    # ** Formatierte Ausgabe der Adresse **
    # Formatierte Ausgabe der Überschrift (zentriert) - Anfang
    headline="${vcardcheck}. ${nachname^} ${vorname^}"
    terminalbreite="$(tput cols)"
    headlinechars="$(echo "$headline" | wc -c)"
    lrleerzeichen=2
    anzlinienzeichen=$((${terminalbreite} - ${headlinechars} - 2 * ${lrleerzeichen}))
    anzliniezeichenlire=$((${anzlinienzeichen}/2 + ${anzlinienzeichen}%2 ))
    printf '%*s' "$anzliniezeichenlire" | tr " " '_'
    printf '%*s' $lrleerzeichen
    printf "$headline"
    printf '%*s' $lrleerzeichen
    printf '%*s\n' "$anzliniezeichenlire" | tr " " '_'
    # Formatierte Ausgabe der Überschrift - Ende
    
    if [ "$misslabel" == "yes" ]; then
     onlylabel2="$(adrprint1)"
    fi
    adrprint1

    # MessDef7
    # *** BriarIDs werden verarbeitet ***
    if [ -n "$briarcontent" ]; then
     anzbriarid="$(echo "$briarcontent" | wc -l)"
     for brid in $(seq 1 "$anzbriarid"); do
      briarline="$(echo "$briarcontent" | sed -n ''${brid}'p')"
      briarname="$(echo "$briarline" | cut -d':' -f3)"
      briarid="$(echo "$briarline" | cut -d':' -f4 | sed 's/^/BriarID '"$brid"'            : briar:\/\//')"
      echo "$briarid (${briarname})"
      if [ "$exportmodus" == "vcfformat" ]; then
       if [ -n "$sonstiges" ]; then
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^NOTE:.*$\)/\1\\nBriarID ('"$briarname"'): briar:\/\/'"$(echo "$briarline" | cut -d':' -f4)"'/')"
       else
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^END:VCARD\)/NOTE:BriarID ('"$briarname"'): briar:\/\/'"$(echo "$briarline" | cut -d':' -f4)"'\n\1/')"
       fi
      elif [ "$exportmodus" == "qrcode" ]; then
       let messcounter++
       bridid="$(echo "$briarline" | cut -d':' -f4 | sed 's/^/briar:\/\//')"
       messprint+="${messcounter};${bridid};Briar;${briarname};${nachname^};${vorname^}"$'\n'
      fi
     done
    fi

    # *** JabberIDs werden verarbeitet ***
    if [ -n "$jabbercontent" ]; then
     anzjid="$(echo "$jabbercontent" | wc -l)"
     for jid in $(seq 1 "$anzjid"); do
      jabline="$(echo "$jabbercontent" | sed -n ''${jid}'p')"
      jabuser="$(echo "$jabline" | cut -d':' -f3)"
      jabservername="$(echo "$jabline" | cut -d':' -f4)"
      echo "JabberID ${jid}           : ${jabuser}@${jabservername} (${jabservername})"
      if [ "$exportmodus" == "vcfformat" ]; then
       if [ -n "$sonstiges" ]; then
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^NOTE:.*$\)/\1\\nJabberID ('"$jabservername"'): '"${jabuser}"'@'"${jabservername}"'/')"
       else
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^END:VCARD\)/NOTE:JabberID ('"$jabservername"'): '"${jabuser}"'@'"${jabservername}"'\n\1/')"
       fi
      elif [ "$exportmodus" == "qrcode" ]; then
       let messcounter++
       jabdid="$(echo "$jabline" | cut -d':' -f3,4 | sed 's/:/@/')"
       messprint+="${messcounter};xmpp:${jabdid};Jabber;${jabservername};${nachname^};${vorname^}"$'\n'
      fi
     done
    fi

    # *** JamiIDs werden verarbeitet ***
    if [ -n "$jamicontent" ]; then
     anzjamiid="$(echo "$jamicontent" | wc -l)"
     for jaid in $(seq 1 "$anzjamiid"); do
      jamiline="$(echo "$jamicontent" | sed -n ''${jaid}'p')"
      jaminame="$(echo "$jamiline" | cut -d':' -f3)"
      jamiid="$(echo "$jamiline" | cut -d':' -f4)"
      echo "JamiID ${jaid}             : ${jamiid} (${jaminame})"
      if [ "$exportmodus" == "vcfformat" ]; then
       if [ -n "$sonstiges" ]; then
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^NOTE:.*$\)/\1\\nJamiID ('"$jaminame"'): '"$jamiid"'/')"
       else
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^END:VCARD\)/NOTE:JamiID ('"$jaminame"'): '"$jamiid"'\n\1/')"
       fi
      elif [ "$exportmodus" == "qrcode" ]; then
       let messcounter++
       jamidid="$(echo "$jamiline" | cut -d':' -f4)"
       messprint+="${messcounter};${jamidid};Jami;${jaminame};${nachname^};${vorname^}"$'\n'
      fi
     done
    fi

    # *** MastodonIDs werden verarbeitet ***
    if [ -n "$mastodoncontent" ]; then
     anzmastoid="$(echo "$mastodoncontent" | wc -l)"
     for mastoid in $(seq 1 "$anzmastoid"); do
      masline="$(echo "$mastodoncontent" | sed -n ''${mastoid}'p')"
      masuser="$(echo "$masline" | cut -d':' -f3)"
      masservername="$(echo "$masline" | cut -d':' -f4)"
      # yes/no-Wert der HTTPS-Überprüfung (mit Funktion wscheck) beim Anlegen des Datensatzes.
      massslcheck="$(echo "$masline" | cut -d':' -f5)"
      [ "$massslcheck" == "yes" ] && scheme="https://"
      echo "MastodonID ${mastoid}         : @${masuser}@${masservername} (${scheme}${masservername}/@${masuser})"
      if [ "$exportmodus" == "vcfformat" ]; then
       if [ -n "$sonstiges" ]; then
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's%\(^NOTE:.*$\)%\1\\nMastodonID ('"$masservername"'): @'"${masuser}"'@'"${masservername}"' ('"${scheme}${masservername}"'/@'"${masuser}"')%')"
       else
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's%\(^END:VCARD\)%NOTE:MastodonID ('"$masservername"'): @'"${masuser}"'@'"${masservername}"' ('"${scheme}${masservername}"'/@'"${masuser}"')\n\1%')"
       fi
      elif [ "$exportmodus" == "qrcode" ]; then
       # Mastodon-Link (https://example.com/@user)
       let messcounter++
       masdid="$(echo "$masline" | cut -d':' -f3,4 | sed 's%\(.*\):\(.*\)%'"$scheme"'\2@\1%')"
       messprint+="${messcounter};${masdid};Mastodon (Link);${masservername};${nachname^};${vorname^}"$'\n'
       # Mastodon-Profil (@user@example.com)
       let messcounter++
       masdid="$(echo "$masline" | cut -d':' -f3,4 | sed 's/^\|:/@/g')"
       messprint+="${messcounter};${masdid};Mastodon (Profil);${masservername};${nachname^};${vorname^}"$'\n'
      fi
     done
    fi

    # *** ToxIDs werden verarbeitet ***
    if [ -n "$toxcontent" ]; then
     anztoxid="$(echo "$toxcontent" | wc -l)"
     for tid in $(seq 1 "$anztoxid"); do
      toxline="$(echo "$toxcontent" | sed -n ''${tid}'p')"
      toxname="$(echo "$toxline" | cut -d':' -f3)"
      toxid="$(echo "$toxline" | cut -d':' -f4)"
      echo "ToxID ${tid}              : ${toxid} (${toxname})"
      if [ "$exportmodus" == "vcfformat" ]; then
       if [ -n "$sonstiges" ]; then
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^NOTE:.*$\)/\1\\nToxID ('"$toxname"'): '"$toxid"'/')"
       else
        vcfsinglecontent="$(echo "$vcfsinglecontent" | sed 's/\(^END:VCARD\)/NOTE:ToxID ('"$toxname"'): '"$toxid"'\n\1/')"
       fi
      elif [ "$exportmodus" == "qrcode" ]; then
       let messcounter++
       toxdid="$(echo "$toxline" | cut -d':' -f4)"
       messprint+="${messcounter};${toxdid};Tox;${toxname};${nachname^};${vorname^}"$'\n'
      fi
     done
    fi
   
    if [ "$exportmodus" == "vcfformat" -a "$vcftype" == "vcf" ]; then
     echo "$vcfsinglecontent" >>"${vcffilename}"
    elif [ "$exportmodus" == "vcfformat" -a "$vcftype" == "qr" ]; then
     qrencode -o "vcfinqrcode_${nachname,,}_${vorname,,}.png" "$(echo "$vcfsinglecontent")"
    fi

    adrprint2
   
    echo -e "\nStand des Datensatzes: ${dateofvcf}"
    
   # Ende der ! "$modifymodus" == "yes" - Verzweigung (Ausgabe auf Bildschirm)
   fi
   
   # Zum debuggen
   # echo "$vcfsinglecontent"
   
  fi
  
  # Hier wird jeweils der bereits getestete Bereich aus der Variable gelöscht.
  vcfcontent="$(echo "$vcfcontent" | sed '1,/END:VCARD/d')"
  if [ "$modifymodus" == "yes" ]; then
   vcfcontentnr="$(echo "$vcfcontentnr" | sed '1,/END:VCARD/d')"
  fi
  
done

if [ "$misslabel" == "yes" -a "$vcardcheck" == "1" ]; then

 echo ""
 printf -- "-%.0s" $(seq $(tput cols))
 echo -e "\n\n*** Fehlender Inhalt (ohne Berücksichtigung von Notizen und Kontaktdaten sonstige) ***"
 labellist2="$(echo "$onlylabel2" | sed '/:/s/^\(.\{21\}\).*/\1/;s/^[[:digit:]]*\.[[:digit:]]* \(.*$\)/* \1 */;/^ /d;/Kontaktdaten sonstige/,$d;/OSM-Link/d')"
 diffliste="$(diff -y --width=90 <(echo "$labellist1") <(echo "$labellist2"))"
 # Mit folgender Anweisung werden alle überflüssigen Unterelemente (also mit content) ausgeblendet: /^\*\|<\|^$/!d
 echo "$diffliste" | sed 's/^\t.*<.*//;s/^\(.*\)\t*|.*$/\1/;/</!s/^\(.\{23\}\).*/\1/;s/\(^\*.*\)</\1/;/^\*/s/\*//3;s/</< fehlt/;/^\*\|<\|^$/!d'

elif [ "$misslabel" == "yes" -a ! "$vcardcheck" == "1" ]; then

 if [ "$vcardcheck" == "0" ]; then
  echo -e "\nKeine passende Übereinstimmung gefunden."
 elif [ "$vcardcheck" -gt "1" ]; then
  echo -e "\nMehrere passende Übereinstimmungen gefunden."
 fi

# Es wird nur eine Zeile in Adressdatei geändert, wenn explizit ein Datensatz gefunden wurde.
elif [ "$modifymodus" == "yes" -a "$vcardcheck" == "1" ]; then

 # / werden gequotet, da es sonst mit sed zu Konflikten kommt.
 [ -n "$fill_abteilung" ] && fill_abteilung="$(echo "$fill_abteilung" | sed 's/\//\\\//g')"
 [ -n "$fill_beruf" ] && fill_beruf="$(echo "$fill_beruf" | sed 's/\//\\\//g')"
 [ -n "$fill_birthday" ] && fill_birthday="$(echo "$fill_birthday" | sed 's/\//\\\//g')"
 [ -n "$fill_email_home1" ] && fill_email_home1="$(echo "$fill_email_home1" | sed 's/\//\\\//g')"
 [ -n "$fill_email_home2" ] && fill_email_home2="$(echo "$fill_email_home2" | sed 's/\//\\\//g')"
 [ -n "$fill_email_work1" ] && fill_email_work1="$(echo "$fill_email_work1" | sed 's/\//\\\//g')"
 [ -n "$fill_email_work2" ] && fill_email_work2="$(echo "$fill_email_work2" | sed 's/\//\\\//g')"
 [ -n "$fill_firma" ] && fill_firma="$(echo "$fill_firma" | sed 's/\//\\\//g')"
 [ -n "$fill_land_home" ] && fill_land_home="$(echo "$fill_land_home" | sed 's/\//\\\//g')"
 [ -n "$fill_land_work" ] && fill_land_work="$(echo "$fill_land_work" | sed 's/\//\\\//g')"
 [ -n "$fill_lang" ] && fill_lang="$(echo "$fill_lang" | sed 's/\//\\\//g')"
 [ -n "$fill_lat_home" ] && fill_lat_home="$(echo "$fill_lat_home" | sed 's/\//\\\//g')"
 [ -n "$fill_lat_work" ] && fill_lat_work="$(echo "$fill_lat_work" | sed 's/\//\\\//g')"
 [ -n "$fill_lon_home" ] && fill_lon_home="$(echo "$fill_lon_home" | sed 's/\//\\\//g')"
 [ -n "$fill_lon_work" ] && fill_lon_work="$(echo "$fill_lon_work" | sed 's/\//\\\//g')"
 [ -n "$fill_mob_home" ] && fill_mob_home="$(echo "$fill_mob_home" | sed 's/\//\\\//g')"
 [ -n "$fill_mob_work" ] && fill_mob_work="$(echo "$fill_mob_work" | sed 's/\//\\\//g')"
 [ -n "$fill_note" ] && fill_note="$(echo "$fill_note" | sed 's/\//\\\//g')"
 [ -n "$fill_ort_home" ] && fill_ort_home="$(echo "$fill_ort_home" | sed 's/\//\\\//g')"
 [ -n "$fill_ort_work" ] && fill_ort_work="$(echo "$fill_ort_work" | sed 's/\//\\\//g')"
 [ -n "$fill_plz_home" ] && fill_plz_home="$(echo "$fill_plz_home" | sed 's/\//\\\//g')"
 [ -n "$fill_plz_work" ] && fill_plz_work="$(echo "$fill_plz_work" | sed 's/\//\\\//g')"
 [ -n "$fill_strasse_home" ] && fill_strasse_home="$(echo "$fill_strasse_home" | sed 's/\//\\\//g')"
 [ -n "$fill_strasse_work" ] && fill_strasse_work="$(echo "$fill_strasse_work" | sed 's/\//\\\//g')"
 [ -n "$fill_tel_home" ] && fill_tel_home="$(echo "$fill_tel_home" | sed 's/\//\\\//g')"
 [ -n "$fill_tel_work" ] && fill_tel_work="$(echo "$fill_tel_work" | sed 's/\//\\\//g')"
 [ -n "$fill_url_home" ] && fill_url_home="$(echo "$fill_url_home" | sed 's/\//\\\//g')"
 [ -n "$fill_url_work" ] && fill_url_work="$(echo "$fill_url_work" | sed 's/\//\\\//g')"

 # Änderung des Geburtstages
 if [ "$modifytype" == "mod" -a -n "$fill_birthday" -a -n "$(echo "$vcfsinglecontentnr" | grep 'BDAY:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*BDAY:.*/\1/p')"
  sed -i ''$linenumber's/\(^BDAY:\).*$/\1'"$fill_birthday"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_birthday" -a -z "$(echo "$vcfsinglecontentnr" | grep 'BDAY:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/BDAY:'"$fill_birthday"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "geburtstag" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*BDAY:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Telefon Festnetz privat
 if [ "$modifytype" == "mod" -a -n "$fill_tel_home" -a -n "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=home,voice')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=home,voice;VALUE=uri:tel:.*/\1/p')"
  sed -i ''$linenumber's/\(^TEL;TYPE=home,voice;VALUE=uri:tel:\).*$/\1'"$fill_tel_home"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_tel_home" -a -z "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=home,voice')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/TEL;TYPE=home,voice;VALUE=uri:tel:'"$fill_tel_home"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "tel_fest_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=home,voice;VALUE=uri:tel:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi

 # Änderung Telefon Mobil privat
 if [ "$modifytype" == "mod" -a -n "$fill_mob_home" -a -n "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=home,cell')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=home,cell;VALUE=uri:tel:.*/\1/p')"
  sed -i ''$linenumber's/\(^TEL;TYPE=home,cell;VALUE=uri:tel:\).*$/\1'"$fill_mob_home"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_mob_home" -a -z "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=home,cell')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/TEL;TYPE=home,cell;VALUE=uri:tel:'"$fill_mob_home"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "tel_mob_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=home,cell;VALUE=uri:tel:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Straße,Hausnummer,PLZ und Ort Privat
 if ([ "$modifytype" == "mod" ] && [ -n "$fill_strasse_home" -o -n "$fill_plz_home" -o -n "$fill_ort_home" -o -n "$fill_land_home" ]) && [ -n "$(echo "$vcfsinglecontentnr" | grep 'ADR;TYPE=home;LABEL')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*ADR;TYPE=home;LABEL.*/\1/p')"
  sed -i ''$linenumber's/\(^ADR;TYPE=home;LABEL=\).*$/\1"'"${fill_strasse_home}"'\\n'"${fill_plz_home}"' '"${fill_ort_home}"'\\n'"${fill_land_home}"'":;;'"${fill_strasse_home}"';'"${fill_ort_home}"';;'"${fill_plz_home}"';'"${fill_land_home}"'/' "${pathofaddress}/address.lst"
 elif ([ "$modifytype" == "mod" ] && [ -n "$fill_strasse_home" -o -n "$fill_plz_home" -o -n "$fill_ort_home" -o -n "$fill_land_home" ]) && [ -z "$(echo "$vcfsinglecontentnr" | grep 'ADR;TYPE=home;LABEL')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/ADR;TYPE=home;LABEL="'"${fill_strasse_home}"'\\n'"${fill_plz_home}"' '"${fill_ort_home}"'\\n'"${fill_land_home}"'":;;'"${fill_strasse_home}"';'"${fill_ort_home}"';;'"${fill_plz_home}"';'"${fill_land_home}"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "str_nr_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*ADR;TYPE=home;LABEL.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Geokoordinaten Wohnsitz Privat
 if ([ "$modifytype" == "mod" ] && [ -n "$fill_lat_home" -a -n "$fill_lon_home" ]) && [ -n "$(echo "$vcfsinglecontentnr" | grep 'GEO;TYPE=home:geo:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*GEO;TYPE=home:geo:.*/\1/p')"
  sed -i ''$linenumber's/\(^GEO;TYPE=home:geo:\).*$/\1'"${fill_lat_home}"','"${fill_lon_home}"'/' "${pathofaddress}/address.lst"
 elif ([ "$modifytype" == "mod" ] && [ -n "$fill_lat_home" -a -n "$fill_lon_home" ]) && [ -z "$(echo "$vcfsinglecontentnr" | grep 'GEO;TYPE=home:geo:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/GEO;TYPE=home:geo:'"${fill_lat_home}"','"${fill_lon_home}"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "geo_wohns_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*GEO;TYPE=home:geo:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Url Privat
 if [ "$modifytype" == "mod" -a -n "$fill_url_home" -a -n "$(echo "$vcfsinglecontentnr" | grep 'URL;TYPE=home:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*URL;TYPE=home:.*/\1/p')"
  sed -i ''$linenumber's/\(^URL;TYPE=home:\).*$/\1'"$fill_url_home"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_url_home" -a -z "$(echo "$vcfsinglecontentnr" | grep 'URL;TYPE=home:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/URL;TYPE=home:'"$fill_url_home"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "url_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*URL;TYPE=home:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Email1 Privat
 if [ "$modifytype" == "mod" -a -n "$fill_email_home1" -a -n "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;PREF=1;TYPE=home:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;PREF=1;TYPE=home:.*/\1/p')"
  sed -i ''$linenumber's/\(^EMAIL;PREF=1;TYPE=home:\).*$/\1'"$fill_email_home1"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_email_home1" -a -z "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;PREF=1;TYPE=home:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/EMAIL;PREF=1;TYPE=home:'"$fill_email_home1"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "email1_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;PREF=1;TYPE=home:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Email2 Privat
 if [ "$modifytype" == "mod" -a -n "$fill_email_home2" -a -n "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;TYPE=home:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;TYPE=home:.*/\1/p')"
  sed -i ''$linenumber's/\(^EMAIL;TYPE=home:\).*$/\1'"$fill_email_home2"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_email_home2" -a -z "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;TYPE=home:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/EMAIL;TYPE=home:'"$fill_email_home2"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "email2_priv" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;TYPE=home:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Firma, Abteilung und Berufsbezeichnung
 if ([ "$modifytype" == "mod" ] && [ -n "$fill_firma" -o -n "$fill_abteilung" -o -n "$fill_beruf" ]) && [ -n "$(echo "$vcfsinglecontentnr" | grep 'ORG:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*ORG:.*/\1/p')"
  sed -i ''$linenumber's/\(^ORG:\).*$/\1'"${fill_firma}"';'"${fill_abteilung}"';'"${fill_beruf}"'/' "${pathofaddress}/address.lst"
 elif ([ "$modifytype" == "mod" ] && [ -n "$fill_firma" -o -n "$fill_abteilung" -o -n "$fill_beruf" ]) && [ -z "$(echo "$vcfsinglecontentnr" | grep 'ORG:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/ORG:'"${fill_firma}"';'"${fill_abteilung}"';'"${fill_beruf}"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "firma" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*ORG:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Telefon Festnetz berufl.
 if [ "$modifytype" == "mod" -a -n "$fill_tel_work" -a -n "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=work,voice')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=work,voice;VALUE=uri:tel:.*/\1/p')"
  sed -i ''$linenumber's/\(^TEL;TYPE=work,voice;VALUE=uri:tel:\).*$/\1'"$fill_tel_work"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_tel_work" -a -z "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=work,voice')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/TEL;TYPE=work,voice;VALUE=uri:tel:'"$fill_tel_work"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "tel_fest_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=work,voice;VALUE=uri:tel:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Telefon Mobil berufl.
 if [ "$modifytype" == "mod" -a -n "$fill_mob_work" -a -n "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=work,cell')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=work,cell;VALUE=uri:tel:.*/\1/p')"
  sed -i ''$linenumber's/\(^TEL;TYPE=work,cell;VALUE=uri:tel:\).*$/\1'"$fill_mob_work"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_mob_work" -a -z "$(echo "$vcfsinglecontentnr" | grep 'TEL;TYPE=work,cell')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/TEL;TYPE=work,cell;VALUE=uri:tel:'"$fill_mob_work"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "tel_mobil_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*TEL;TYPE=work,cell;VALUE=uri:tel:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Straße,Hausnummer,PLZ und Ort berufl.
 if ([ "$modifytype" == "mod" ] && [ -n "$fill_strasse_work" -o -n "$fill_plz_work" -o -n "$fill_ort_work" -o -n "$fill_land_work" ]) && [ -n "$(echo "$vcfsinglecontentnr" | grep 'ADR;TYPE=work;LABEL')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*ADR;TYPE=work;LABEL.*/\1/p')"
  sed -i ''$linenumber's/\(^ADR;TYPE=work;LABEL=\).*$/\1"'"${fill_strasse_work}"'\\n'"${fill_plz_work}"' '"${fill_ort_work}"'\\n'"${fill_land_work}"'":;;'"${fill_strasse_work}"';'"${fill_ort_work}"';;'"${fill_plz_work}"';'"${fill_land_work}"'/' "${pathofaddress}/address.lst"
 elif ([ "$modifytype" == "mod" ] && [ -n "$fill_strasse_work" -o -n "$fill_plz_work" -o -n "$fill_ort_work" -o -n "$fill_land_work" ]) && [ -z "$(echo "$vcfsinglecontentnr" | grep 'ADR;TYPE=work;LABEL')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/ADR;TYPE=work;LABEL="'"${fill_strasse_work}"'\\n'"${fill_plz_work}"' '"${fill_ort_work}"'\\n'"${fill_land_work}"'":;;'"${fill_strasse_work}"';'"${fill_ort_work}"';;'"${fill_plz_work}"';'"${fill_land_work}"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "str_nr_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*ADR;TYPE=work;LABEL.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Geokoordinaten Wohnsitz berufl.
 if ([ "$modifytype" == "mod" ] && [ -n "$fill_lat_work" -a -n "$fill_lon_work" ]) && [ -n "$(echo "$vcfsinglecontentnr" | grep 'GEO;TYPE=work:geo:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*GEO;TYPE=work:geo:.*/\1/p')"
  sed -i ''$linenumber's/\(^GEO;TYPE=work:geo:\).*$/\1'"${fill_lat_work}"','"${fill_lon_work}"'/' "${pathofaddress}/address.lst"
 elif ([ "$modifytype" == "mod" ] && [ -n "$fill_lat_work" -a -n "$fill_lon_work" ]) && [ -z "$(echo "$vcfsinglecontentnr" | grep 'GEO;TYPE=work:geo:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/GEO;TYPE=work:geo:'"${fill_lat_work}"','"${fill_lon_work}"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "geo_wohns_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*GEO;TYPE=work:geo:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Url berufl.
 if [ "$modifytype" == "mod" -a -n "$fill_url_work" -a -n "$(echo "$vcfsinglecontentnr" | grep 'URL;TYPE=work:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*URL;TYPE=work:.*/\1/p')"
  sed -i ''$linenumber's/\(^URL;TYPE=work:\).*$/\1'"$fill_url_work"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_url_work" -a -z "$(echo "$vcfsinglecontentnr" | grep 'URL;TYPE=work:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/URL;TYPE=work:'"$fill_url_work"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "url_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*URL;TYPE=work:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Email1 berufl.
 if [ "$modifytype" == "mod" -a -n "$fill_email_work1" -a -n "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;PREF=1;TYPE=work:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;PREF=1;TYPE=work:.*/\1/p')"
  sed -i ''$linenumber's/\(^EMAIL;PREF=1;TYPE=work:\).*$/\1'"$fill_email_work1"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_email_work1" -a -z "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;PREF=1;TYPE=work:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/EMAIL;PREF=1;TYPE=work:'"$fill_email_work1"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "email1_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;PREF=1;TYPE=work:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Email2 berufl.
 if [ "$modifytype" == "mod" -a -n "$fill_email_work2" -a -n "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;TYPE=work:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;TYPE=work:.*/\1/p')"
  sed -i ''$linenumber's/\(^EMAIL;TYPE=work:\).*$/\1'"$fill_email_work2"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_email_work2" -a -z "$(echo "$vcfsinglecontentnr" | grep 'EMAIL;TYPE=work:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/EMAIL;TYPE=work:'"$fill_email_work2"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "email2_beruf" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*EMAIL;TYPE=work:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Notiz
 if [ "$modifytype" == "mod" -a -n "$fill_note" -a -n "$(echo "$vcfsinglecontentnr" | grep 'NOTE:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*NOTE:.*/\1/p')"
  sed -i ''$linenumber's/\(^NOTE:\).*$/\1'"$fill_note"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_note" -a -z "$(echo "$vcfsinglecontentnr" | grep 'NOTE:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/NOTE:'"$fill_note"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "notiz" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*NOTE:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi
 
 # Änderung Sprache
 if [ "$modifytype" == "mod" -a -n "$fill_lang" -a -n "$(echo "$vcfsinglecontentnr" | grep 'LANG:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*LANG:.*/\1/p')"
  sed -i ''$linenumber's/\(^LANG:\).*$/\1'"$fill_lang"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -n "$fill_lang" -a -z "$(echo "$vcfsinglecontentnr" | grep 'LANG:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$linenumber's/\(END:VCARD\)/LANG:'"$fill_lang"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a "$modtype" == "sprache" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*LANG:.*/\1/p')"
  if [ "$linenumber" -gt "0" ]; then
   sed -i ''"$linenumber"'d' "${pathofaddress}/address.lst"
  else
   echo "Keinen Eintrag zum Löschen gefunden."
  fi
 fi

 # Zeitstempel wird aktualisiert.
 # 1.   mod - Eine bestehende Zeile wurde zuvor geändert - Anzahl der Zeilen ist identisch
 # 2.   mod - Eine Zeile mit Zeitstempel wurde zuvor hinzugefügt - Anzahl der Zeilen erhöht sich um 1
 # 3+4. del - Eine bestehende Zeile wurde zuvor gelöscht - Anzahl der Zeilen verringert sich um 1
 # Hinweis: Der Zeitstempel wird generell dann angewendet, wenn die Adressdatei zum Ändern (nicht ccat) geöffnet wurde.
 # Also auch dann, wenn ggf. der Inhalt gar nicht geändert wurde.
 if [ "$modifytype" == "mod" -a -n "$(echo "$vcfsinglecontentnr" | grep 'REV:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*REV:.*/\1/p')"
  sed -i ''$linenumber's/^\(REV:\).*$/\1'"$(date +%Y%m%dT%H%M%SZ)"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "mod" -a -z "$(echo "$vcfsinglecontentnr" | grep 'REV:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$(($linenumber + 1))'s/\(END:VCARD\)/REV:'"$(date +%Y%m%dT%H%M%SZ)"'\n\1/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a -n "$(echo "$vcfsinglecontentnr" | grep 'REV:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*REV:.*/\1/p')"
  sed -i ''$(($linenumber - 1))'s/^\(REV:\).*$/\1'"$(date +%Y%m%dT%H%M%SZ)"'/' "${pathofaddress}/address.lst"
 elif [ "$modifytype" == "del" -a -z "$(echo "$vcfsinglecontentnr" | grep 'REV:')" ]; then
  linenumber="$(echo "$vcfsinglecontentnr" | sed -n 's/\(^[[:digit:]]*\).*END:VCARD.*/\1/p')"
  sed -i ''$(($linenumber - 1))'s/\(END:VCARD\)/REV:'"$(date +%Y%m%dT%H%M%SZ)"'\n\1/' "${pathofaddress}/address.lst"
 fi

elif [ "$modifymodus" == "yes" -a "$vcardcheck" -gt "1" ]; then

  echo -e "\nEs wurden ${vcardcheck} Einträge gefunden. Bitte Suche mit einem Vornamen spezifizieren."

# Ende Verzweigung: "$modifymodus" == "yes" -a "$vcardcheck" == "1"
fi
   
[ "$modifymodus" == "yes" ] && adrencrypt

# Ausgabe einer MessengerID als QR-Code auf der Standardausgabe.
if [ "$exportmodus" == "qrcode" ]; then
 echo -e '\n                    *** Export einer MessengerID als QR-Code ***'
 #printf -- "─%.0s" $(seq $(tput cols))
 # Bildschirm-Ausgabe
 printf 'Num ID                                                                               Messenger          Mess-Name  Nachname   Vorname\n'
 #printf -- "─%.0s" $(seq $(tput cols))
 while read -r line; do
  [ -n "$line" ] && printf '%3d %-80s %-18.18s %-10.10s %-10.10s %-10.10s\n' "$(echo "$line" | cut -f1 -d';')" \
                                                                             "$(echo "$line" | cut -f2 -d';')" \
                                                                             "$(echo "$line" | cut -f3 -d';')" \
                                                                             "$(echo "$line" | cut -f4 -d';')" \
                                                                             "$(echo "$line" | cut -f5 -d';')" \
                                                                             "$(echo "$line" | cut -f6 -d';')"
 done <<<"$messprint"
 #printf -- "─%.0s" $(seq $(tput cols))
 echo ""
 while [ -z "$(echo "$messprint" | grep "^${messausw};")" ]; do
  read -p "Bitte Auswahl eingeben: " messausw
 done
 selectedmessid="$(echo "$messprint" | grep "^${messausw};" | cut -f2 -d';')"
 read -p "Soll der QR-Code auf [S]tandardausgabe oder als PNG-[B]ild ausgegeben werden? " qrexport
 while true; do
  case "$qrexport" in
    s|S) qrencode -o - -t ASCIIi "$selectedmessid"
         qrtype="stout"
         break
        ;;
    b|B) qrencode -o "vcfinqrcode_${nachname,,}_${vorname,,}.png" "$selectedmessid"
         qrtype="bild"
         break
        ;;
      *) echo "Fehlerhafte Eingabe"
        ;;
  esac
 done
fi

# Die vcf-Elemente, die in einem QR-Code umgewandelt werden, sind aufgrund ihrer Größe
# in eine png-Datei gespeichert. Diese wird nach dem Anzeigen sofort wieder gelöscht.
if [ "$exportmodus" == "vcfformat" -a "$vcftype" == "qr" ] || [ "$exportmodus" == "qrcode" -a "$qrtype" == "bild" ]; then

 # xdg-open - öffnet die Datei mit dem Standard-Bildbetrachter des Benutzers.
 # Der find-Befehl in Verbindung mit exec ist nötig, da xdg-open nicht mehrere Dateien auf einmal öffnet.
 find . -maxdepth 1 -type f -name vcfinqrcode\*.png -exec xdg-open {} \;
 if [ "$?" == "0" ]; then
  rm -i ./vcfinqrcode*.png
 else
  echo "Datei(en) vcfinqrcode*.png befindet sich nun im Ordner ${PWD}"
 fi
 
fi

# MessDef8
if [ "$vcardcheck" == "0" ]; then
 
  echo "Es konnte keine Vcard mit dem Namen ${*} ermittelt werden."
  
  checkbriarcontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:BRIAR/,/END:BRIAR/p' | grep -ci '^'"$nachname"':')"
  checkjabbercontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:XMPP/,/END:XMPP/p' | grep -ci '^'"$nachname"':')"
  checkjamicontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:JAMI/,/END:JAMI/p' | grep -ci '^'"$nachname"':')"
  checkmastodoncontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:MASTODON/,/END:MASTODON/p' | grep -ci '^'"$nachname"':')"
  checktoxcontent="$(echo "$adrlistcontent" | sed -n '/BEGIN:TOX/,/END:TOX/p' | grep -ci '^'"$nachname"':')"
  if [ "$checkbriarcontent" -gt "0" -o "$checkjabbercontent" -gt "0" -o "$checkjamicontent" -gt "0" -o "$checkmastodoncontent" -gt "0" -o "$checktoxcontent" -gt "0" ]; then
   echo "Es wurden ${checkbriarcontent} BriarIDs, ${checkjabbercontent} JabberIDs, ${checkjamicontent} JamiIDs, ${checkmastodoncontent} MastodonIDs und ${checktoxcontent} ToxIDs mit dem Namen ${1^} ermittelt."
   echo "Bitte erst einen passenden VCARD-Datensatz erstellen mit $0 -n vcf"
  fi
  
fi
 
echo ""

# Inhalt und Passwort löschen
unset adrlistcontent
unset mysecpassw
# Backupordner aufräumen
if [ "$maxbackupfiles" -ge 0 ]; then
 dellist1="$(ls -tQ "${pathofaddress}"/backupfiles/*_address.lst.cpt 2>/dev/null | sed -n ''$(("$maxbackupfiles" + 1))',$p')"
 dellist2="$(ls -tQ "${pathofaddress}"/backupfiles/*_hash.log 2>/dev/null | sed -n ''$(("$maxbackupfiles" + 1))',$p')"
 [ -n "$dellist1" ] && xargs rm <<<"$dellist1"
 [ -n "$dellist2" ] && xargs rm <<<"$dellist2"
fi
